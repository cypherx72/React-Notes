
---
### **Why Use `useReducer` Instead of `useState`?** Â 

1. **Centralized State Management** â€“ All state updates are handled in one place (the reducer function), making it easier to manage and debug.

2. **Clearer State Transitions** â€“ Actions explicitly define what is happening, making the logic more readable.

3. **Avoids Repetitive Patterns** â€“ Instead of always using the function form of `useState` updates (`prevState => newState`), `useReducer` naturally handles updates with the latest state snapshot.

4. **Decouples Business Logic from Components** â€“ The reducer function is independent of the component, making it easier to test and maintain.

---
### **Understanding Reducers** Â 

- A **reducer function** reduces multiple values to **a single value**. Â 

- Similar to JavaScript's `reduce()` method (e.g., summing an array). Â 

- `useReducer` follows this approach **to update state** in React.

  
---

### **Implementing `useReducer`** Â 


#### **1. Using `useReducer` in `CartContextProvider`** Â 

- Replace `useState` with `useReducer`. Â 

- `useReducer` returns **two values**: Â 

Â  1. `shoppingCartState` â€“ The **current state**. Â 

Â  2. `shoppingCartDispatch` â€“ A **function to dispatch actions**. Â   

```jsx
const [shoppingCartState, shoppingCartDispatch] = useReducer(
Â  shoppingCartReducer,
Â  { items: [] } // Initial state
);
```


---

#### **2. Creating the Reducer Function** Â 

- Define `shoppingCartReducer` **outside** the component (prevents unnecessary re-creations). Â 

- It takes **two parameters**: Â 

Â  1. `state` â€“ The current state. Â 

Â  2. `action` â€“ The dispatched action. Â 

```js
function shoppingCartReducer(state, action) {
Â  return state; // Placeholder (update logic later)
}
```


---

#### **3. Connecting `useReducer` to the Context** Â 

```jsx
const [shoppingCartState, shoppingCartDispatch] = useReducer(
Â  shoppingCartReducer,
Â  { items: [] }
);
```

At this stage, the cart **only shows an empty array**.

---

#### **4. Dispatching Actions** Â 

- The **dispatch function** updates state by sending an **action**. Â 

- Actions define **what should happen** in the reducer. Â 

- Example **action types**: Â 

Â  - `"ADD_ITEM"` â€“ Adds a new item. Â 

Â  - `"REMOVE_ITEM"` â€“ Removes an item. Â 


```js
function shoppingCartReducer(state, action) {
Â  switch (action.type) {
Â  Â  case "ADD_ITEM":
Â  Â  Â  return { ...state, items: [...state.items, action.payload] };
Â  Â  case "REMOVE_ITEM":
Â  Â  Â  return { ...state, items: state.items.filter(item => item.id !== action.payload.id) };
Â  Â  default:
Â  Â  Â  return state;
Â  }
}
```

  
---

#### **5. Using `dispatch` to Update State** Â 
```js
shoppingCartDispatch({ type: "ADD_ITEM", payload: newItem });
```

---
### **1ï¸âƒ£ How `useReducer` Works**

When you call: Â 

```js

const [shoppingCartState, shoppingCartDispatch] = useReducer(shoppingCartReducer, initialState);
```

- `shoppingCartState` â†’ Holds the **current state**.

- `shoppingCartDispatch` â†’ A function that **sends actions** to the reducer.

---

### **2ï¸âƒ£ How the Reducer Function Receives Parameters**

A reducer function always takes **two** parameters: Â 

```js
function shoppingCartReducer(state, action) {
```

- **`state`** â†’ The current state (which React provides automatically).

- **`action`** â†’ The action object dispatched (e.g., `{ type: "ADD_ITEM", payload: newItem }`).

So, the correct reducer function should be:

```js
function shoppingCartReducer(state, action) {
Â  switch (action.type) {
Â  Â  case "ADD_ITEM":
Â  Â  Â  return { ...state, items: [...state.items, action.payload] };
Â  Â  default:
Â  Â  Â  return state;
Â  }
}
```

---

### **3ï¸âƒ£ How Dispatch Works**

When calling `shoppingCartDispatch`, we **only pass an action**, like this: Â 

```js
shoppingCartDispatch({ type: "ADD_ITEM", payload: newItem });
```

- React **automatically provides** the current state when calling `shoppingCartReducer(state, action)`.

- We do **not** need to manually pass `shoppingCartState` when calling `dispatch`.

---
### **Final Code Example**

```js

const initialState = { items: [] };

function shoppingCartReducer(state, action) {
Â  switch (action.type) {
Â  Â  case "ADD_ITEM":
Â  Â  Â  return { ...state, items: [...state.items, action.payload] };
Â  Â  default:
Â  Â  Â  return state;
Â  }
}

function ShoppingCart() {
Â  const [shoppingCartState, shoppingCartDispatch] = useReducer(shoppingCartReducer, initialState);

Â  function addItem() {
Â  Â  const newItem = { id: Date.now(), name: "Laptop" };
Â  Â  shoppingCartDispatch({ type: "ADD_ITEM", payload: newItem }); // âœ… No need to pass shoppingCartState manually
Â  }
Â  return (
Â  Â  <div>
Â  Â  Â  <button onClick={addItem}>Add Item</button>
Â  Â  Â  <ul>
Â  Â  Â  Â  {shoppingCartState.items.map(item => (
Â  Â  Â  Â  Â  <li key={item.id}>{item.name}</li>
Â  Â  Â  Â  ))}
Â  Â  Â  </ul>
Â  Â  </div>
Â  );
}

```

---

  

### **ğŸ’¡ Key Takeaways**

âœ… `useReducer` automatically manages state updates. Â 
âœ… The reducer function always receives `(state, action)`. Â 
âœ… You only pass an `action` object to `dispatch()`. Â 
âœ… React ensures that `state` is passed internally to `shoppingCartReducer`. Â 

### **Benefits of `useReducer`** Â 

âœ… **Centralized state logic** â€“ Easier maintenance. Â 
âœ… **Predictable updates** â€“ Actions are clear and structured. Â 
âœ… **Scales well** â€“ Handles complex state better than `useState`. Â 

By integrating `useReducer`, **React state management becomes more efficient and scalable**. Â 

---