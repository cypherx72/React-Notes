
---

Using `useEffect` unnecessarily is a bad practice because it introduces an extra execution cycle after the component render. Not all side effects require `useEffect`, and sometimes, directly handling logic within an event handler is the best approach.

---

### **Example: Storing Selected Places in `localStorage` Without `useEffect`** Â 

In this example, we store a selected place's `id` in the browserâ€™s `localStorage` when a user clicks on it.


```jsx
import { useState } from "react";

function App() {
Â  const [selectedPlaces, setSelectedPlaces] = useState([]);
Â  const handleSelectPlace = (id) => {
Â  
Â  Â  // Retrieve stored places from localStorage
Â  Â  const storedIds = JSON.parse(localStorage.getItem("selectedPlaces")) || [];

Â  Â  // Check if the place is already stored
Â  Â  if (storedIds.indexOf(id) === -1) {
Â  Â  Â  const updatedIds = [id, ...storedIds];
Â  Â  Â  
Â  Â  Â  // Store updated places in localStorage
Â  Â  Â  localStorage.setItem("selectedPlaces", JSON.stringify(updatedIds));
  
Â  Â  Â  // Update React state to reflect changes
Â  Â  Â  setSelectedPlaces(updatedIds);
Â  Â  }
Â  };

Â  return (
Â  Â  <div>
Â  Â  Â  <h1>Available Places</h1>
Â  Â  Â  <button onClick={() => handleSelectPlace(1)}>Select Place 1</button>
Â  Â  Â  <button onClick={() => handleSelectPlace(2)}>Select Place 2</button>
Â  Â  Â  <p>Selected Places: {JSON.stringify(selectedPlaces)}</p>
Â  Â  </div>
Â  );
}
```


---

### **Why `useEffect` is Not Needed Here**

âœ… The side effect (storing in `localStorage`) only runs **when a user clicks a button**. Â 
âœ… It does **not** create an infinite loop. Â 
âœ… It does **not** depend on the component rendering; it happens due to **user interaction**. Â 
âœ… `useEffect` is mainly needed when:

Â  Â - A side effect should run **after a render** (e.g., fetching data).

Â  Â - A side effect depends on state updates and might cause **unintended re-renders**.

---  

### **Key Takeaways**

- **Avoid overusing `useEffect`** â€“ it adds extra execution cycles.

- **Use `useEffect` for side effects that should run after a render**, like:

Â  - Fetching data from an API

Â  - Subscribing to events

Â  - Running timers

- **Directly run logic inside event handlers** if it is triggered by user interaction.


### **Optimizing `localStorage` Usage Without `useEffect` in React** Â 

Previously, we stored selected places in `localStorage` when a user clicked a button. Now, weâ€™ll enhance the implementation by: Â 
âœ… **Allowing places to be removed** from `localStorage`. Â 
âœ… **Fetching stored places** when the app starts. Â 
âœ… **Avoiding unnecessary use of `useEffect`** by handling `localStorage` synchronously.
  

---
### **1ï¸âƒ£ Removing Places from `localStorage`** Â 

Instead of just adding places, we also need to remove them when a user clicks on a selected place.

```jsx
const handleRemovePlace = (id) => {
Â  const storedIds = JSON.parse(localStorage.getItem("selectedPlaces")) || [];

Â  // Remove the selected place

Â  const updatedIds = storedIds.filter((placeId) => placeId !== id);

  

Â  localStorage.setItem("selectedPlaces", JSON.stringify(updatedIds));

Â  setSelectedPlaces(updatedIds);

};

```

ğŸš€ **How it works:** Â 

- We **retrieve** the stored places. Â 

- We **filter out** the selected place. Â 

- We **update** `localStorage` with the new list. Â 

- We **update state** to reflect the change in the UI.

  

---
### **2ï¸âƒ£ Fetching Data When the App Starts (Without `useEffect`)** Â 

Instead of using `useEffect` to load data when the app starts, we can fetch it **before initializing state**.

  

```jsx
// Load stored places before component execution
const storedPlaces = JSON.parse(localStorage.getItem("selectedPlaces")) || [];

function App() {
Â  const [selectedPlaces, setSelectedPlaces] = useState(storedPlaces);
Â  
Â  return <div>...</div>;
}
```

ğŸ“Œ **Why is `useEffect` unnecessary here?** Â 

âœ… **Fetching from `localStorage` is synchronous** (it happens instantly). Â 
âœ… The app **does not need to wait** for an async response (like fetching from an API). Â 
âœ… This **prevents unnecessary re-renders** that `useEffect` might cause.

---

### **3ï¸âƒ£ Further Optimization â€“ Move Storage Fetching Outside the Component** Â 

For better performance, move storage fetching **outside the component**, so it runs **only once** when the app starts.

```jsx
// Fetch stored places once (outside the component)
const storedPlaces = JSON.parse(localStorage.getItem("selectedPlaces")) || [];

function App() {
Â  const [selectedPlaces, setSelectedPlaces] = useState(storedPlaces);
Â  
Â  return <div>...</div>;
}
```

ğŸ”¹ **Now, `localStorage` is accessed only once** when the file is loaded, rather than every time the component re-renders.

  
---

### **Key Takeaways** Â 
- **Donâ€™t overuse `useEffect`** â€“ Only use it for asynchronous or event-driven side effects. Â 

- **Fetching from `localStorage` is synchronous**, so it can be done before initializing state. Â 

- **Optimize performance** by moving storage-related logic outside the component when possible.

---
