

---
## **Working with Lists in React** Â 

- When rendering a list using `.map()`, **each element must have a unique `key` prop** for React to track changes efficiently. Â 

- **Example:** Â 

Â  ```jsx
Â  const items = ["Apple", "Banana", "Cherry"];
Â  return (
Â  Â  <ul>
Â  Â  Â  {items.map((item, index) => (
Â  Â  Â  Â  <li key={index}>{item}</li>
Â  Â  Â  ))}
Â  Â  </ul>
Â  );
Â  ```

- **Why use keys?** Â 

Â  - Keys help React identify which items changed, added, or removed. Â 
Â  
Â  - Using indexes as keys (`key={index}`) is acceptable for static lists but **not recommended for dynamic lists** that may change. Â 

---  

## **1ï¸âƒ£ Updating Objects & Arrays in React State**

ğŸ”¹ **Never mutate state directly** â†’ Always create a new copy before modifying. Â 

  
âœ… **Use JavaScript's Spread Operator for Copies** Â 

```jsx
const newArray = [...oldArray]; // Shallow copy
const newObject = { ...oldObject }; // Shallow copy
```
  

âœ… **Deep Copy for Nested Data (Avoid Shallow Copies)** Â 

```jsx
const deepCopy = oldArray.map(item => ({ ...item }));
```


---

## **2ï¸âƒ£ Lifting State Up**

ğŸ”¹ When **two or more components need shared state**, move it **to their closest common ancestor** and pass it as props.


âœ… **Example: Sharing Active Player State**

```jsx
function App() {
Â  Â  const [activePlayer, setActivePlayer] = useState("Player 1");

Â  Â  return (
Â  Â  Â  Â  <>
Â  Â  Â  Â  Â  Â  <GameBoard activePlayer={activePlayer} />
Â  Â  Â  Â  Â  Â  <PlayerSwitch onSwitch={() => setActivePlayer(prev => prev === "Player 1" ? "Player 2" : "Player 1")} />
Â  Â  Â  Â  </>
Â  Â  );
}
```

- **GameBoard** gets `activePlayer` as a prop. Â 

- **PlayerSwitch** updates `activePlayer` using a function passed from **App**.
  

---

  
## **3ï¸âƒ£ Managing Lists: Adding, Editing, and Deleting Items**

ğŸ”¹ **Lists should be stored in state as an array of objects.** Â 

ğŸ”¹ **Use functional updates (`prevState => newState`) to ensure the latest state is used.**


âœ… **Adding Items to a List**

```jsx
function handleAddItem(newItem) {
Â  Â  setItems(prevItems => [...prevItems, newItem]);
}
```


âœ… **Editing an Item**

```jsx
function handleEditItem(index, updatedValue) {
Â  Â  setItems(prevItems =>
Â  Â  Â  Â  prevItems.map((item, i) => i === index ? updatedValue : item)
Â  Â  );
}
```


âœ… **Deleting an Item**

```jsx
function handleDeleteItem(index) {
Â  Â  setItems(prevItems => prevItems.filter((_, i) => i !== index));
}
```


âœ… **Using a Unique ID Instead of Index**

- **Indexes may change when reordering items** â†’ Use a unique `id` instead.

```jsx
function handleDeleteItem(id) {
Â  Â  setItems(prevItems => prevItems.filter(item => item.id !== id));
}
```


---

## **4ï¸âƒ£ Derived State in React**

ğŸ”¹ **Avoid storing redundant state!** Â 

ğŸ”¹ **If a value can be computed from existing state, compute it dynamically inside the component.** Â 


âœ… **Example: Avoid Storing Duplicate State**

```jsx
const [price, setPrice] = useState(100);
const [tax, setTax] = useState(20); // âŒ Bad practice
// âœ… Compute derived state inside render
const totalPrice = price + tax;
```

  
âœ… **Better Approach: Compute Inside Component**

```jsx
const totalPrice = useMemo(() => price * 1.2, [price]); // 20% tax
```


âœ… **Another Example: Filtering a List Dynamically**

```jsx

const filteredItems = useMemo(() => items.filter(item => item.completed), [items]);

```

- The list updates **only when `items` change**, preventing unnecessary calculations.


---  

## **5ï¸âƒ£ Placing Functions Outside Components**

ğŸ”¹ **Functions that donâ€™t depend on the component state or props** should be **moved outside the component** to improve performance.


âœ… **Example: Move Utility Function Outside**

```jsx
function formatPrice(price) {
Â  Â  return `$${price.toFixed(2)}`;
}

function Product({ price }) {
Â  Â  return <p>Price: {formatPrice(price)}</p>;
}
```

- `formatPrice` is **independent** of `Product` â†’ Move it **outside**.

  
---

### **ğŸ“Œ Summary: React State Management Best Practices**

âœ” **Never mutate state directly. Always create a copy first.** Â 
âœ” **Lift state up to the closest ancestor when needed.** Â 
âœ” **Use `map()`, `filter()`, and `useMemo()` to update and derive state efficiently.** Â 
âœ” **Use unique IDs instead of indexes when working with lists.** Â 
âœ” **Compute derived values inside render functions instead of storing extra state.** Â 
âœ” **Move independent functions outside components for performance optimization.** Â 

  
ğŸš€ **Following these practices leads to cleaner, optimized, and scalable React apps!**