 
---

## ğŸ”¥ **Problem Overview** Â 

- In a React app, state updates in the parent component (e.g., `App`) can trigger **re-renders** in all child components â€” even when the state is unrelated to the child components. Â 

- Example: Â 

Â  Â  - An `input` field in the `App` component updates state on each keystroke. Â 

Â  Â  - This causes **all child components** (e.g., `Counter`, `Header`) to be executed again â€” even though their state or props didnâ€™t change. Â   

---  

## ğŸš€ **Why This is a Problem**

- While the actual **DOM might not change** when React re-executes components, the component functions are still being executed. Â 

- This consumes **CPU resources** and slows down performance unnecessarily. Â 

- React re-executes the component function because: Â 

Â  Â  - State changed â†’ React re-executes the parent component. Â 

Â  Â  - Child components are part of the parentâ€™s JSX â†’ React re-executes them too. Â 

  
---


## ğŸ› ï¸ **Solution 1: `React.memo()`**

- `React.memo()` is a **higher-order component** that prevents unnecessary re-renders by memorizing the output of a component. Â 

- It wraps a component and **compares the current props with the previous props**: Â 

Â  Â  - If the props are **identical** â†’ Skip re-execution of the component. Â 

Â  Â  - If the props **changed** â†’ Re-execute the component. Â 

  
### âœ… **How to Use `memo()`** Â 

1. **Import `memo`** from React: Â 

```jsx
import React, { memo } from 'react';
```

2. **Wrap the component** using `memo()`:

```jsx
const Counter = memo(function Counter({ initialCount }) {
Â  // Component code...
});
```

3. **Best Practice:** Â 

Â  Â - Store the wrapped component in a **constant** and export it: Â 

```jsx
const Counter = memo(function Counter({ initialCount }) {
Â  return <div>{initialCount}</div>;
});

export default Counter;
```


---

## âš™ï¸ **How `memo()` Works**

- When React would normally re-execute the component, `memo()` does the following: Â 

Â  Â  1. Compares **previous prop values** with **new prop values**. Â 

Â  Â  2. If the values are exactly the same â†’ **Skip execution**. Â 

Â  Â  3. If the values are different â†’ **Re-execute the component**. Â 

Â  Â  4. If state inside the component itself changes â†’ `memo()` does **NOT** prevent the execution. Â 


---

## ğŸ“Œ **Example**

### Before `memo()`:

1. App re-renders â†’ All child components (`Header`, `Counter`, etc.) re-execute. Â 

2. Even if `Counter` props are the same â†’ It still executes. Â 

### After `memo()`:

1. App re-renders. Â 

2. `memo()` checks props: Â 

Â  Â  - If unchanged â†’ Skip execution of `Counter`. Â 

Â  Â  - If changed â†’ Execute `Counter` only. Â 


---

## ğŸ† **Best Practices for `memo()`**

âœ… Use `memo()` only when: Â 

- The component re-renders frequently but **props stay unchanged**. Â 

- The component is **high up** in the component tree â†’ Prevents deeper re-renders. Â 

- The component is **computationally expensive** to execute. Â 


âŒ Donâ€™t use `memo()` when: Â 

- Props change **almost every time** â†’ Prop comparison adds overhead. Â 

- Components are simple â†’ No noticeable performance gain. Â 

- State inside the component is changing often â†’ `memo()` doesnâ€™t prevent state-based updates. Â 

  

---

## ğŸš¨ **Why Not to Overuse `memo()`**

- `memo()` adds a small **performance cost** for comparing props. Â 

- If props change often â†’ You waste CPU checking props instead of just executing the component. Â 

- Example: Â 

Â  Â  - If props always change â†’ `memo()` becomes **a performance bottleneck** instead of an improvement. Â 

---

## ğŸ¯ **Key Takeaways** Â 

âœ… `memo()` prevents unnecessary re-renders by comparing props. Â 
âœ… Best used for **components high up** in the tree. Â 
âœ… Works only for **prop-based** re-renders, not internal state changes. Â 
âœ… Donâ€™t overuse â€” use it **strategically** for performance gains.