 Â ---
## **What is Prop Drilling?** Â 

- **Prop drilling** occurs when **shared data** needs to be passed **through multiple layers** of components before reaching the necessary component. Â 

- This can make the code **hard to maintain** and **less scalable**. Â 

  
---

## **Solutions to Prop Drilling** Â 

### **1ï¸âƒ£ Component Composition** (Using `children` Props) Â 

- **Definition:** Â 

Â  - A **design pattern** where components are used as **building blocks** by nesting them together. Â 

Â  - Instead of passing props down multiple layers, **parent components can directly provide children with the required data**. Â 

- **How it works:** Â 

Â  ```jsx
Â  function Card({ children }) {
Â  Â  return <div className="card">{children}</div>;
Â  }
  
Â  function App() {
Â  Â  return (
Â  Â  Â  <Card>
Â  Â  Â  Â  <h2>Product Title</h2>
Â  Â  Â  Â  <p>Product Description</p>
Â  Â  Â  </Card>
Â  Â  );
Â  }
Â  ```

- **Why it helps?** Â 

Â  âœ… **Reduces unnecessary prop passing** in deeply nested components. Â 

Â  âœ… **Makes components reusable** and **easier to manage**. Â 


---  

### **2ï¸âƒ£ React's Context API** Â 

- **What is it?** Â 

Â  - A **built-in React feature** for **sharing data** across multiple components **without** passing props manually at every level. Â 

#### **How Context API Works (3 Steps)** Â 

### **Step 1: Create a Context** Â 

- Context acts as a **container** that holds shared state. Â 

Â  ```jsx

Â  import React, { createContext } from 'react';
Â  // Creating the context
Â  const MyContext = createContext("defaultValue");
Â  export default MyContext;
Â  ```

  
---

### **Step 2: Provide the Context Value** Â 

- Use `Context.Provider` to **wrap** components that need access to the shared data. Â 
-
- The **context must be provided** to the component tree so that **nested components** can access its values. Â 

- This is done in the `App` component, where `CartContext.Provider` wraps around the necessary components.

  ```jsx

Â  import React from 'react';
Â  import MyContext from './store/my-context';
Â  import ChildComponent from './ChildComponent';

Â  function App() {
Â  Â  return (
Â  Â  Â  <MyContext.Provider value="Hello from Context!">
Â  Â  Â  Â  <ChildComponent />
Â  Â  Â  </MyContext.Provider>
Â  Â  );
Â  }

Â  export default App;
Â  ```

- **Key Points:** Â 

Â  âœ… `MyContext.Provider` **wraps** components that need access to the shared state. Â 

Â  âœ… The `value` prop **stores** the data to be shared. Â 
Â    
### **ğŸ“Œ Why Provide Context at the App Level?** Â 

âœ… Wrapping the **entire application (or a major section)** ensures **all child components** (like `Header`, `Shop`, and their descendants) have access to the shared context **without prop drilling**.

  
---

### **Step 3: Consume the Context in a Component** Â 

#### **Option 1: Using `useContext` Hook (Modern Approach)**


- **For Functional Components**: Â 

Â  ```jsx

Â  import React, { useContext } from 'react';
Â  import MyContext from './store/my-context';

Â  function ChildComponent() {
Â  Â  const value = useContext(MyContext);
Â  Â  return <p>{value}</p>;
Â  }

Â  export default ChildComponent;
Â  ```

- **Why `useContext`?** Â 

Â  âœ… **Cleaner & easier** than manually passing props. Â 
Â  âœ… **No need for multiple intermediate components**. Â 
Â   

## **Destructuring Context Values** Â 

- Instead of accessing `cartCtx.items`, you can **destructure values** for cleaner code.

### **âœ… Example: Destructuring Context Values** Â 

```jsx
const { items } = useContext(CartContext);
```

âœ… **Now you can use `items` directly**, rather than `cartCtx.items`.

#### **Option 2: Using `<MyContext.Consumer>` (Old Approach, Rarely Used)**

- **For Class Components**: Â 

Â  ```jsx
Â  import React from 'react';
Â  import MyContext from './store/my-context';

Â  class ChildComponent extends React.Component {
Â  Â  render() {
Â  Â  Â  return (
Â  Â  Â  Â  <MyContext.Consumer>
Â  Â  Â  Â  Â  {(value) => <p>{value}</p>}
Â  Â  Â  Â  </MyContext.Consumer>
Â  Â  Â  );
Â  Â  }
Â  }

Â  export default ChildComponent;
Â  ```

- **Why is this approach outdated?** Â 

Â  - More **verbose** than `useContext`. Â 

Â  - `useContext` is the **recommended way** in modern React.

  
---

## **ğŸ“Œ Example: Context API in a Shopping Cart** Â 


### **Project Setup** Â 

ğŸ“ **Create a `store/` folder inside `src/`** Â 

- This is a **common convention** for managing global state. Â 

ğŸ“„ **Create a file**: `shopping-cart-context.jsx` inside `store/` Â 


### **Step 1: Creating the Shopping Cart Context** Â 

```jsx
import React, { createContext } from 'react';

// Create Context
const CartContext = createContext({
Â  items: [] // Default value
});

export default CartContext;
```

- **Naming Convention:** Â 

Â  âœ… **`CartContext` is capitalized** to follow Reactâ€™s component naming rules. Â 


---

### **Step 2: Providing the Context to Components** Â 

```jsx
import React from 'react';
import CartContext from './store/shopping-cart-context';
import Header from './components/Header';
import Shop from './components/Shop';

function App() {
Â  return (
Â  Â  <CartContext.Provider value={{ items: [] }}>
Â  Â  Â  <Header />
Â  Â  Â  <Shop />
Â  Â  </CartContext.Provider>
Â  );
} 

export default App;
```

- **Key Points:** Â 

Â  âœ… **`CartContext.Provider` wraps** all components that need the shared cart data. Â 
Â  âœ… **`value` prop** passes the shared state (`items: []`). Â 
Â  âœ… If a component is **not wrapped** in `<CartContext.Provider>`, it will use the **default value** from `createContext()`. Â 

  

---
### **ğŸ“Œ Why Use `useContext` Instead of Props?** Â 

âœ… **Avoids prop drilling** (no need to manually pass `items` through multiple components). Â 
âœ… **Makes data flow more efficient & easier to manage**. Â 


---

## **Optional Alternative: Using the `use` Hook (React 19+)** Â 

- **React 19 introduced the `use` hook**, which can also be used to consume context. Â 

- **It works like `useContext` but can be used inside conditional blocks**, making it more flexible.


### **âœ… Example: Using the `use` Hook in React 19+** Â 

```jsx
const cartCtx = use(CartContext);
```

âš ï¸ **Note:** Â 

- `use` is **only available in React 19+**, so **`useContext` is preferred** for backward compatibility. Â   

---

## **Why Set a Default Value in `createContext()`?** Â 

- **Providing a default value** improves:

Â  âœ… **Auto-completion & TypeScript support** (VSCode suggests properties like `items` automatically). Â 
Â  âœ… **Better developer experience** by making the **context's structure predictable**.
Â  
Â 
### **Final Notes & Summary** Â 

âœ… **Prop drilling** happens when data is passed through multiple layers unnecessarily. Â 
âœ… **Component Composition** (using `children` props) is a way to **avoid excessive prop passing**. Â 
âœ… **Context API** is a built-in solution to **share state globally** without manually passing props. Â 
âœ… **The `useContext` hook** is the preferred way to consume context in functional components. Â 
âœ… **Project structure best practices** include keeping global state management in a **dedicated `store/` folder**. Â 

---

