

---

### ğŸ§¹ Initial Cleanup

Before adding your own pages:

1. **Delete** the following:
    
    - `pages/api/` folder â€” not needed unless you're building an API.
        
    - `pages/index.js` â€” to start fresh.
        
    - `styles/Home.module.css` â€” unused styles.
        
2. **Keep**:
    
    - `pages/_app.js` â€” needed for global configuration (weâ€™ll ignore it for now).
        
    - `styles/globals.css` â€” optional but useful for global styling.
        

---

### ğŸŒ Goal: Create a Simple Website With 3 Pages

Weâ€™re building a basic site with:

- `/` â€“ Home page
    
- `/news` â€“ News listing page
    
- `/news/[id]` â€“ Dynamic route for a specific news item (handled later)
    

---

### ğŸ›  Step-by-Step Page Setup

#### 1. `pages/index.js` â†’ Home Page

```js
function HomePage() {
  return <h1>The Home Page</h1>;
}

export default HomePage;
```

ğŸ“Œ `index.js` is special â€” it's served at `/` (the root of your domain).

---

#### 2. `pages/news.js` â†’ News Listing Page

```js
function NewsPage() {
  return <h1>The News Page</h1>;
}

export default NewsPage;
```

ğŸ“Œ `news.js` maps to `/news`. The filename (excluding `.js`) becomes the route.

---

### ğŸ§ª Run the App

In your project terminal, run:

```bash
npm run dev
```

Then visit:

- [http://localhost:3000/](http://localhost:3000/) â†’ Home Page
    
- [http://localhost:3000/news](http://localhost:3000/news) â†’ News Page
    

---

### ğŸ” Key Feature: Pre-rendering in Next.js

- When you **View Page Source** in your browser, youâ€™ll **see the full HTML content** already there.
    
- This is **not** how a typical React app behaves (which loads an empty `div` and fills it in later).
    
- Benefits:
    
    - âœ… Faster first paint
        
    - âœ… Better SEO (search engines can crawl real content)
        
    - âœ… No content flicker or blank screens
        

---

### ğŸ§  Summary: What You Just Did

|Concept|Description|
|---|---|
|File-based routing|File name = URL path (`news.js` â†’ `/news`)|
|`index.js`|Represents the root (`/`) route|
|Pre-rendered pages|HTML is generated server-side by default|
|No `import React`|Not needed in modern React (Next.js handles it)|

You're now up and running with routing and SSR, without touching a single config file. 

---

### File-Based Routing and Nested Routes in Next.js (`pages` Directory)

---

#### âœ… **Recap: Basic Routing in Next.js**

- Files inside the `/pages` folder define **routes**.
    
    - `index.js` â†’ `/`
        
    - `news.js` â†’ `/news`
        
- Each file should **export a React component** which gets rendered when the corresponding route is accessed.
    
- Pre-rendering works out of the box â€” meaning each page is rendered on the server first and sent with full HTML.
    

---

#### ğŸ§© **Alternative: Folder + `index.js`**

- Instead of using `news.js` inside `/pages`, you can create:
    
    ```
    /pages/news/index.js
    ```
    
    - This also maps to `/news` route.
        
    - **Reason to do this:** helps keep code organized, especially when nesting routes.
        

---

#### ğŸ“ **Nested Routing**

To handle routes like:

```
/news/something-important
```

You need nested folders:

```
/pages/news/
  â”œâ”€ index.js              â†’ /news
  â””â”€ something-important.js â†’ /news/something-important
```

Alternatively:

```
/pages/news/
  â””â”€ something-important/index.js â†’ /news/something-important
```

---

#### ğŸ§  Key Concepts

- **Folders = URL segments.**
    
- `index.js` always maps to the root of the folder's path.
    
- Named files inside folders represent the **next segment** in the route.
    

---

#### ğŸ—‚ï¸ Why This Matters

- Using this system lets you build **hierarchical and organized structures** for your pages.
    
- Essential for scalable apps with nested routes (e.g., `/blog/[slug]`, `/dashboard/settings/account`, etc.).
    

---



### Dynamic Routes in Next.js (`pages` Directory)

---

#### ğŸ” **The Problem with Hardcoding Routes**

- If you want to show **multiple news items**, hardcoding files like:
    
    ```
    /pages/news/something-important.js
    ```
    
    is **not scalable**.
    
- Youâ€™ll likely have:
    
    - `/news` â†’ list of news items
        
    - `/news/[newsId]` â†’ details of a selected item
        

---

#### ğŸ”¥ **Solution: Dynamic Routing**

Next.js supports **dynamic file-based routing** using square brackets:

```
/pages/news/[newsId].js
```

- This route will match:
    
    - `/news/this-course-is-great`
        
    - `/news/123`
        
    - `/news/anything-else`
        
- The same component renders, but the content changes based on the `newsId`.
    

---

#### ğŸ§  Why It's Important

- Allows us to reuse a single component (`[newsId].js`) to display different content.
    
- This is **how you build scalable content-driven sites** (e.g., blogs, product pages).
    

---

#### âš™ï¸ How It Works

- Next.js recognizes `[newsId].js` as a **dynamic route**.
    
- It automatically captures the value in the URL path.
    
- You'll learn how to **extract** that dynamic value next (using `useRouter` or `getStaticProps`).
    

---

#### ğŸ“ Example Folder Structure:

```
/pages/
  â”œâ”€ news/
  â”‚   â”œâ”€ index.js            â†’ /news (List of news items)
  â”‚   â””â”€ [newsId].js         â†’ /news/some-id (Detail page for a news item)
```

an alternative approach: 

To handle dynamic URLs like `/some-meetup-id`:

- Use **square brackets** to define the file/folder name:
    
    ```bash
    pages/[meetupId]/index.js
    ```
    
- This sets up a dynamic route where `meetupId` is a placeholder and can be used to fetch specific data based on the route.
    

### Example:

If the URL is `/m1`, the page `pages/[meetupId]/index.js` will render, and `meetupId` will be `'m1'`.

---

### Extracting Dynamic Route Parameters with `useRouter` in Next.js

---

#### ğŸ“¦ **Importing the Hook**

To access dynamic URL values in a functional component, Next.js provides a built-in React hook:

```js
import { useRouter } from 'next/router';
```

---

#### ğŸ§° **Using `useRouter`**

Inside your component:

```js
const router = useRouter();
console.log(router.query.newsId);
```

- `router.query` returns an object containing all dynamic route parameters.
    
- The key (e.g., `newsId`) matches the name in your file:  
    `/pages/news/[newsId].js` â†’ `router.query.newsId`.
    

---

#### ğŸ” **Hook Behavior**

- When the page first renders, `router.query.newsId` is `undefined`.
    
- Then Next.js **hydrates** the page, and a second render happens with the actual value.
    
- This is **normal behavior** â€” the hook doesn't have full URL context on the first render (especially during SSR).
    

---

#### âš™ï¸ **Example Usage**

```js
const NewsDetailPage = () => {
  const router = useRouter();
  const { newsId } = router.query;

  console.log(newsId); // might log undefined initially, then "this-course-is-great"
  
  return <p>News ID: {newsId}</p>;
};

export default NewsDetailPage;
```

---

#### ğŸ¯ **Why It's Useful**

You can now use `newsId` to:

- Fetch a **specific news item** from a database or API.
    
- Display dynamic content based on the path.
    
- Navigate between pages programmatically (though not used here).
    


---

**ğŸ“„ _app.js â€“ Wrapping All Pages with a Global Layout**

- The `_app.js` file in the `pages` directory is a **special Next.js file**.
    
- It allows you to define **global configuration** and **common layout** for all pages.
    
- The default component receives two props:
    
    - `Component`: the page component to render.
        
    - `pageProps`: props for that page (can be empty or filled via data fetching).
        
- Use it to **wrap every page** with components like a layout, theme provider, or global styles.
    

**ğŸ’¡ Why use _app.js:**

- Prevents the need to wrap every page manually with `<Layout>`.
    
- Keeps your code DRY and more maintainable.
    
- Automatically applies the layout across all routes.
    

**âœ… Implementation Example:**

```js
import Layout from '../components/layout/Layout';

function MyApp({ Component, pageProps }) {
  return (
    <Layout>
      <Component {...pageProps} />
    </Layout>
  );
}

export default MyApp;
```

**ğŸ› ï¸ Steps followed:**

1. Created `Layout` component that uses `props.children`.
    
2. Initially used it in `index.js` to wrap page content manually.
    
3. Moved layout wrapping to `_app.js` to apply globally.
    
4. Removed layout wrapping from individual pages like `index.js`.
    
5. Now all pages (like `New Meetup`) show the navigation bar and layout automatically.
    

---


**ğŸš€ Programmatic Navigation with `useRouter` â€“ Show Details Button**

Instead of using a `<Link>` component, we can navigate **programmatically** using the `useRouter` hook from `next/router`. This is especially useful when:

- Submitting a form then redirecting
    
- Conditionally navigating
    
- Using buttons instead of links
    

**ğŸ“Œ Setup Steps:**

1. **Import `useRouter`:**
    

```js
import { useRouter } from 'next/router';
```

2. **Get the router object:** React hooks must be called at the top level of the component.
    

```js
const router = useRouter();
```

3. **Create a handler function:**
    

```js
function showDetailsHandler() {
  router.push(`/${props.id}`);
}
```

4. **Attach to a button:**
    

```jsx
<button onClick={showDetailsHandler}>Show Details</button>
```

This navigates to a dynamic route like `/m1`, `/m2`, etc., using the `id` passed as a prop.

**ğŸ“ Note:**

- Using `<Link>` would be more semantic for navigation, but this approach is ideal when navigation is tied to a user action (like form submission or button click).



## Fetching Data After Component Mount (useEffect) â€“ Drawbacks in Next.js

---

### ğŸ› ï¸ Current Setup

- **Dummy data** (`DUMMY_MEETUPS`) is hard-coded into the component.
    
- In `index.js`, we pass this data directly into props.
    

---

### ğŸ§  Simulating Backend Fetching

To simulate fetching from a backend:

- Use the `useEffect` hook to trigger data fetching **after component mounts**.
    
- Manage fetched data using the `useState` hook.
    

```js
import { useState, useEffect } from 'react';

useEffect(() => {
  // simulate HTTP request
  setLoadedMeetups(DUMMY_MEETUPS); // pretend this came from a server
}, []);
```

---

### âš™ï¸ What Happens Internally

1. **First Render Cycle**:
    
    - `loadedMeetups` is initially an **empty array**.
        
2. **After `useEffect` Runs**:
    
    - State is updated â†’ component re-renders â†’ now `loadedMeetups` contains data.
        

---

### â— The Problem: SEO & Pre-rendering

- **Next.js only pre-renders** the output of the **first render cycle**.
    
- Since `loadedMeetups` is empty during the first cycle:
    
    - The server-rendered HTML has **no actual content**.
        
    - HTML source shows an empty list â†’ **SEO suffers**.
        
- Even if data is available instantly, this gap still exists due to how `useEffect` is executed.
    

---

### ğŸ’¡ Why This Matters

- Good SEO requires that the HTML **already contains the content**.
    
- With client-side data fetching (`useEffect`), HTML is empty at first â†’ bad for SEO, bots, or preview snippets.
    

---
