
---

In this section, we focus on the **basic (primitive) types** in TypeScript, which you'll use frequently.

### ğŸ¯ Primitive Types in TypeScript

- `number` â†’ for all numbers (integers & floats)
    
- `string` â†’ for text values
    
- `boolean` â†’ for true/false
    
- `null` and `undefined` â†’ used less often directly
    
- _(Ignore `symbol` for now)_
    

> âœ… Use lowercase for primitive type annotations:  
> `number`, `string`, `boolean` â†’ âœ…  
> `Number`, `String`, `Boolean` â†’ âš ï¸ refers to object wrappers, not primitive types.

---

### ğŸ§  Syntax: Type Annotations

```ts
let age: number;
age = 24;       // âœ… valid
age = 24.5;     // âœ… valid
age = "24";     // âŒ Error: string not assignable to number

let username: string = "cypher_x";
let isInstructor: boolean = true;
```

You can also declare and assign at once:

```ts
let price: number = 99.99;
```

---

### âš ï¸ About `null` and `undefined`

```ts
let hobbies = null; // TypeScript allows it, but not practical

hobbies = ["reading"]; // âŒ Type error if type is inferred as null
```

- `null`/`undefined` are considered types but aren't used as standalone variable types often.
    
- We'll explore how to **properly use them** (e.g., in union types like `string | null`) in upcoming sections.
    

---

### ğŸ”‘ Takeaway

- Always use **lowercase** when assigning types.
    
- Use **primitive types** to ensure variables hold the correct kind of data.
    
- TypeScript will catch incorrect assignments during development, reducing runtime bugs.
    

---

## TypeScript: Complex Types â€” Arrays and Objects

In addition to primitive types, TypeScript allows you to define **complex types** like arrays and objects. These help enforce structure and consistency in your code.

---

### ğŸ”¹ Arrays

To declare an array of a specific type:

```ts
let hobbies: string[]; // Array of strings
hobbies = ["reading", "coding"]; // âœ…
hobbies.push("gaming");          // âœ…
hobbies.push(100);               // âŒ Error: number not assignable to string
```

> âœ… Works for any primitive or custom type:  
> `number[]`, `boolean[]`, `User[]`, etc.

---

### ğŸ”¸ Objects

To define an object with a fixed structure:

```ts
let person: {
  name: string;
  age: number;
};

person = {
  name: "Cypher",
  age: 20
}; // âœ…

person = {
  isEmployee: true
}; // âŒ Error: doesn't match object structure
```

#### âš ï¸ Avoid `any` type:

```ts
let person: any; // Avoid this â€” allows any value
```

> Using `any` defeats the purpose of TypeScript's type safety.

---

### ğŸ” Arrays of Objects

To define an array of structured objects:

```ts
let people: {
  name: string;
  age: number;
}[];

people = [
  { name: "Alice", age: 22 },
  { name: "Bob", age: 30 }
]; // âœ…

people.push({ isEmployee: true }); // âŒ Invalid structure
```

---

### ğŸ”‘ Key Takeaways

- Use `type[]` to define arrays.
    
- Use `{}` to define object structures.
    
- Combine them for arrays of objects.
    
- Avoid `any` unless there's a very specific reason.
    


---

## TypeScript: Type Inference

TypeScript has a powerful **type inference** system, which automatically determines the type of a variable based on the **initial value** you assign to it.

---

### ğŸ”¹ Example

```ts
let course = "React - The Complete Guide"; // Inferred as string

course = 12345; // âŒ Error: number not assignable to string
```

> Even though no explicit type was declared, TypeScript _infers_ `course` to be of type `string` from its initial value.

---

### ğŸ”¸ Why It Matters

- **Less code**: You donâ€™t have to write out the type if itâ€™s obvious.
    
- **More readable**: Keeps your code cleaner.
    
- **Still type-safe**: TypeScript will throw errors if you later try to assign a value of the wrong type.
    

---

### âœ… Best Practice

If you're assigning an **initial value** during declaration, **donâ€™t repeat the type** unnecessarily.

```ts
// âœ… Clean and recommended
let isPublished = true;

// âŒ Redundant
let isPublished: boolean = true;
```

---

### ğŸ”‘ Key Takeaways

- Type inference kicks in when you **initialize a variable with a value**.
    
- TypeScript infers the type and enforces it from that point forward.
    
- You **can** still manually declare types, but only do so when necessary (e.g., no initial value, complex types, or clarity).
    

---

## TypeScript: Union Types

By default, variables in TypeScript are assigned **a single type**. But when a variable needs to support **multiple types**, we use **union types**.

---

### ğŸ”¹ What Are Union Types?

A **union type** allows a variable to hold **more than one possible type**.

You define a union type using the **pipe (`|`) symbol** between the allowed types.

---

### ğŸ”¸ Example

```ts
let course: string | number;

course = "React - The Complete Guide"; // âœ…
course = 12345;                        // âœ…
course = true;                         // âŒ Error: boolean not allowed
```

> This allows either a `string` or `number`, but not a `boolean`.

---

### ğŸ§  Use Case

Union types are useful when:

- Input/output types are flexible
    
- APIs return different types
    
- You support multiple data structures (e.g., object OR array)
    

---

### ğŸ” Another Example

```ts
let username: string | string[];

username = "Max";             // âœ…
username = ["Max", "Smith"];  // âœ…
username = 10;                // âŒ
```

---

### âœ… Best Practice

Use union types when:

- A variable is legitimately allowed to hold multiple types
    
- Type inference doesnâ€™t work or is too restrictive
    

Avoid overusing them as a workaround for unclear data structures â€” keep your types **intentional and safe**.

---

### ğŸ”‘ Key Takeaways

- Use `|` to combine types: `string | number | boolean`, etc.
    
- TypeScript will enforce that only the **allowed types** can be assigned.
    
- Makes your code more **flexible** but still **type-safe**.
    

---
