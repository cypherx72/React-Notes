
---

1. **Reducer Functions in Redux:**
   - **Must be pure, side-effect free, and synchronous.**
   - Take input (old state and action) and produce output.
   - This applies not only to Redux reducers but also to reducer functions passed to React's `useReducer` hook.
   - For the same input, the output should always be the same, without any side effects or asynchronous code.

2. **Handling Side Effects in Redux:**
   - Reducers cannot handle side effects (e.g., HTTP requests) because they must remain pure and synchronous.
   - **Two possible places to handle side effects:**
     - **Directly in the component:** Use hooks like `useEffect` to perform side effects and dispatch actions once the side effect is complete. Redux remains unaware of the side effect.
     - **Custom action creators:** Write your own action creators (instead of using Redux Toolkit's auto-generated ones) to handle side effects and asynchronous tasks. Redux provides solutions for this.

3. **Upcoming Topics:**
   - Both approaches (handling side effects in components and custom action creators) will be explored in the course.
   - A basic React-Redux application will be set up in the next two lectures as a foundation for exploring asynchronous code and Redux.
   - These setup lectures can be skipped if already familiar with the basics, but it’s recommended to follow along for reinforcement.

4. **Key Takeaway:**
   - Reducers must remain pure and synchronous, so side effects and asynchronous code must be handled outside of reducers, either in components or custom action creators.


- ## Connecting Redux with Side Effects and Asynchronous Code

1. **Goal:**
   - Integrate a backend (Firebase) to store and retrieve cart data.
   - Whenever the cart is updated (items added, removed, or quantity changed), send a request to the backend to save the updated cart.
   - On application reload, fetch the saved cart from the backend and display it.

2. **Backend Choice:**
   - Firebase is used for simplicity (no backend code required).
   - Alternatively, a custom backend (e.g., Node.js) could be built, but this course focuses on React and Redux.

3. **Key Problem:**
   - Currently, cart data is lost on page reload because it’s not stored anywhere.
   - Solution: Store cart data on the backend and fetch it when the application reloads.

4. **Redux Constraints:**
   - **Reducers must remain pure, side-effect free, and synchronous.**
   - **HTTP requests (side effects) cannot be placed inside reducers.**
   - Example: Sending a request to update the backend after modifying the cart state in the reducer is **not allowed**.

5. **Options for Handling Side Effects:**
   - **Option 1: Execute side effects in components.**
     - Ignore Redux for side effects (e.g., use `useEffect` in components to send requests).
     - Dispatch Redux actions only after the side effect is complete.
   - **Option 2: Use action creators.**
     - Create custom action creators (not auto-generated by Redux Toolkit) to handle asynchronous code or side effects.
     - This approach keeps side effects out of reducers while still integrating with Redux.

6. **Upcoming Content:**
   - Both options (side effects in components and custom action creators) will be demonstrated.
   - This will allow you to compare the approaches and decide which one to use in your projects.

7. **Key Takeaway:**
   - Reducers must never contain side effects or asynchronous code.
   - Side effects (e.g., HTTP requests) should be handled either in components or custom action creators.


## Running Async Code and Side Effects in Components

1. **Starting Point:**
   - Handle asynchronous code and side effects inside components.
   - Example: Adding items to the cart from the `ProductItem` component.

2. **Current Workflow:**
   - The `addToCartHandler` dispatches an action to update the Redux store.
   - Goal: Also send the updated cart data to Firebase (backend) when adding items.

3. **Problem with Firebase:**
   - Firebase (in this setup) is a "dumb" backend—it only stores data as received without any transformation logic.
   - The logic in the Redux reducer (e.g., checking if a product is already in the cart, updating quantities) does not exist on Firebase.
   - If Firebase receives product data, it simply stores it without applying any cart logic.

4. **Alternative Backend Options:**
   - **Firebase Functions:** Allows adding server-side logic to Firebase for transforming data.
   - **Custom Backend (e.g., Node.js, PHP):** Enables full control over backend logic, including data transformation.
   - However, this course focuses on React and Redux, not backend development.

5. **Frontend-Backend Interaction:**
   - The amount of work done on the frontend depends on the backend's capabilities.
   - If the backend handles data transformation (e.g., updating the cart), the frontend can simply send raw data and store the backend's response in Redux.
   - In this case, the backend does not transform data, so the frontend must handle all transformation logic (e.g., updating the cart in Redux).

6. **Key Constraints:**
   - Reducers must remain pure and synchronous—no side effects (e.g., HTTP requests) allowed.
   - The frontend must handle both:
     - Transforming data (e.g., updating the cart in Redux).
     - Sending the updated data to the backend.

7. **Solution:**
   - Perform data transformation in Redux reducers (as currently done).
   - Send the updated data to the backend **outside the reducer** (e.g., in the component or a custom action creator).

8. **Next Steps:**
   - Determine where to place the code for sending updated cart data to the backend.
   - Ensure the backend request is not made inside the reducer but still integrates with Redux.

9. **Key Takeaway:**
   - The frontend must handle data transformation and backend communication when the backend does not perform these tasks.
   - Reducers must remain pure and free of side effects, so backend requests must be handled outside of reducers (e.g., in components or custom action creators).


## Handling Async Code and Data Transformation in Components

1. **Problem Recap:**
   - The backend (Firebase) does not perform data transformation (e.g., updating cart logic).
   - The frontend must handle both:
     - Data transformation (e.g., updating the cart).
     - Sending the updated data to the backend.
   - Reducers must remain pure and synchronous, so HTTP requests cannot be made inside reducers.

2. **Two Main Options for Handling Async Code:**
   - **In Components:** Perform data transformation and send HTTP requests directly in components.
   - **In Action Creators:** Use custom action creators to handle async code and side effects.

3. **Starting with Components:**
   - Example: `ProductItem` component's `addToCartHandler`.
   - Use `useSelector` from `react-redux` to get the current cart state.
   - Perform data transformation (e.g., updating cart items and total quantity) **without mutating the Redux state**.
   - Dispatch an action to update the Redux store with the transformed data.

4. **Key Constraint: Avoid Mutating Redux State:**
   - Mutating Redux state outside of reducers is **not allowed**.
   - Example: Updating `cart.totalQuantity` directly in the component would mutate the Redux state, which is **bad practice**.
   - Instead, create new constants (e.g., `newTotalQuantity`, `updatedItems`) to avoid mutating the existing state.

5. **Code Example (Attached):**
   - In `addToCartHandler`:
     - Use `useSelector` to get the current cart.
     - Create a new `newTotalQuantity` and `updatedItems` array without mutating the existing state.
     - Dispatch a `replaceCart` action to update the Redux store with the new cart data.
   - This approach avoids mutating the Redux state and keeps the transformation logic outside the reducer.

6. **Problems with This Approach:**
   - **Code Duplication:** If this logic is needed in multiple components (e.g., `CartItem`), it would need to be duplicated or extracted into a helper function.
   - **Suboptimal Code Structure:** Data transformation logic belongs in reducers, not components.
   - **Reducers Become Thin:** Reducers would only store data without performing any transformation, which goes against the Redux philosophy.

7. **General Rule for Code Placement:**
   - **Synchronous, Side-Effect-Free Code (Data Transformation):**
     - Prefer **reducers** over components or action creators.
   - **Asynchronous Code or Code with Side Effects (HTTP Requests):**
     - Prefer **action creators** or **components**.
     - **Never** use reducers for side effects or async code.

8. **Current Issue:**
   - The current approach places data transformation logic in the component, which is **suboptimal**.
   - A better approach is needed to keep transformation logic in reducers while handling async code outside reducers.

9. **Next Steps:**
   - Explore a better way to handle data transformation in reducers and async code in action creators or components.
   - Avoid duplicating logic and keep the code structure aligned with Redux best practices.

10. **Key Takeaway:**
    - Data transformation logic should ideally reside in reducers, while async code (e.g., HTTP requests) should be handled in action creators or components.
    - Avoid mutating Redux state outside of reducers and ensure code structure aligns with Redux principles.