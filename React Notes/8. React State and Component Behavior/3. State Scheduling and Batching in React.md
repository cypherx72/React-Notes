
Understanding how state updates are scheduled and executed by React is crucial for avoiding common bugs and improving performance.

---

## ğŸ”„ **How State Updates Are Scheduled**

1. When you call a state updating function like `setChosenCount`:

Â  Â - The state update is **scheduled** â€” not executed immediately.

Â  Â - React schedules the update and will process it during the next render cycle. Â 

2. If you log the state **immediately after updating it**:

Â  Â - You will see the **old state** because the new state is not yet applied. Â 

Â  Â - The state will update only when the component **re-executes**. Â 


---

### ğŸ§ª **Example â€“ Why Immediate Logging Fails**

```jsx
setChosenCount(10);
console.log(chosenCount); // Logs the old state, not 10
```

- The state update (`setChosenCount(10)`) is **scheduled**. Â 

- The `console.log()` runs before the next render, so it shows the old state. Â 


---

## ğŸ› ï¸ **Solution â€“ Function Form of State Updates**

React allows you to use a **function form** for state updates:
  

```jsx
setChosenCount((prevChosenCount) => prevChosenCount + 1);
```

### âœ… **Why Function Form Works**

- The function receives the latest state value (`prevChosenCount`). Â 

- React guarantees that the state value passed to the function is **up-to-date**. Â 

- If multiple state updates are scheduled together, they will be processed **in order** and React will always pass the correct latest value. Â 

---

### ğŸ”¥ **Example â€“ Incorrect Way:**

If you try to set state based on the old value directly:

```jsx
setChosenCount(newCount);
setChosenCount(newCount + 1);
```

- The second `setChosenCount` will not work correctly because `newCount` is stale.

- It will add `1` to the old state instead of the updated value. Â 

### âœ… **Correct Way Using Function Form:**

```jsx
setChosenCount(newCount);

setChosenCount((prevChosenCount) => prevChosenCount + 1);

```

- The second update will work correctly because it gets the latest state value.

- The second `setChosenCount` is guaranteed to execute **after the first update**. Â 

---

## ğŸ·ï¸ **State Batching**

If multiple state updates happen **within the same function**:

- React will **batch** them together into a single update cycle.

- This prevents multiple component re-renders and makes the update more efficient.

### ğŸ§ª **Example â€“ State Batching:**

```jsx
setChosenCount(10);
setOtherState(20);
```

- React will only execute **one render** even though two state updates are called.

- This improves performance since React avoids unnecessary renders.

---

### ğŸš€ **Why Batching is Efficient:**

- Without batching â†’ Two state updates = Two component re-renders Â 

- With batching â†’ Two state updates = **One component re-render** Â 


---

## ğŸŒŸ **Key Takeaways:**

âœ… State updates are **scheduled**, not executed instantly. Â 
âœ… Use **function form** for state updates based on the previous state. Â 
âœ… Multiple state updates within a function are **batched** to reduce renders. Â 
âœ… React ensures state updates are processed **in order** and efficiently. ğŸ˜