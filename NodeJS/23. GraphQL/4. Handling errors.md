Great question. You're at the point where you've built a mutation (`createUser`) in GraphQL and added input validation using the `validator` package. Now, you're asking: **how can we include more detailed data in the thrown error response**â€”such as _which fields_ failed, and _why_?

Letâ€™s go step-by-step and show how to throw a **custom error** with **rich data**, including multiple validation messages.

---

### âœ… Step 1: Update the Error Throwing Logic

Instead of throwing a simple `Error`, throw a custom `Error` object and attach a custom property like `data`, which GraphQL can expose in the error response.

Hereâ€™s what your enhanced validation and error logic might look like in the resolver:

```js
const validator = require('validator');

createUser: async function({ userInput }, req) {
  const errors = [];

  // Validate email
  if (!validator.isEmail(userInput.email)) {
    errors.push({ field: 'email', message: 'E-mail is invalid.' });
  }

  // Validate password
  if (
    validator.isEmpty(userInput.password) ||
    !validator.isLength(userInput.password, { min: 5 })
  ) {
    errors.push({ field: 'password', message: 'Password too short. Min 5 characters required.' });
  }

  // If there are any validation errors, throw a custom error
  if (errors.length > 0) {
    const error = new Error('Invalid input.');
    error.code = 422;
    error.data = errors; // Attach custom error data
    throw error;
  }

  // If validation passed, continue creating the user...
  // your logic here
}
```

---

### âœ… Step 2: Ensure GraphQL Returns This Custom Error Data

GraphQL doesnâ€™t return custom error properties by default. You need to **ensure your server setup allows error formatting**.

If youâ€™re using `express-graphql`, use the `customFormatErrorFn` option:

```js
app.use('/graphql', graphqlHTTP({
  schema: schema,
  rootValue: resolvers,
  graphiql: true,
  customFormatErrorFn(err) {
    if (!err.originalError) return err;
    const data = err.originalError.data;
    const message = err.message || 'An error occurred.';
    const code = err.originalError.code || 500;
    return {
      message: message,
      status: code,
      data: data
    };
  }
}));
```

This makes sure your custom `error.data` and `error.code` are passed back to the frontend.

---

### âœ… Step 3: Sample Error Response in GraphQL Playground

If you now send an invalid request, your GraphQL Playground (or any client) will return a structured error:

```json
{
  "errors": [
    {
      "message": "Invalid input.",
      "status": 422,
      "data": [
        { "field": "email", "message": "E-mail is invalid." },
        { "field": "password", "message": "Password too short. Min 5 characters required." }
      ]
    }
  ]
}
```

---

### âœ… Step 4: Bonus â€“ Handling in Frontend

On the frontend, you can now check the `data.errors[0].data` array and show **field-specific validation errors**.

Example (in React):

```js
const errors = data.errors?.[0]?.data;
errors?.forEach(err => {
  console.log(`${err.field}: ${err.message}`);
});
```

---

### ðŸ§  Final Thought

This approach lets you maintain **fine-grained, reusable validation** logic inside your resolversâ€”just like you did with middleware in RESTâ€”and still gives your frontend all the data it needs to handle and display errors properly.

Would you like me to help you set up a utility function to handle validation in a reusable way across multiple resolvers?