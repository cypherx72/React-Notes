Perfect. You’re now building **“createPost”** into the backend and preparing the frontend to send new posts. Let’s break this down step by step and wire it up properly. I’ll keep it clean and aligned with what your video/code tutorial is describing.

---

## ✅ Backend: Add Post Creation (with user attachment)

### 1️⃣ **Schema Changes**

In your `graphql/schema.js` (or `schema.graphql` if split):

```graphql
input PostInputData {
  title: String!
  content: String!
  imageUrl: String!
}

type Post {
  _id: ID!
  title: String!
  content: String!
  imageUrl: String!
  creator: User!   # Assuming a post is tied to a user
  createdAt: String!
  updatedAt: String!
}

type RootMutation {
  createPost(postInput: PostInputData): Post!
  # ... other mutations like createUser, login
}
```

---

### 2️⃣ **Resolver**

In `graphql/resolvers.js`:

```js
const Post = require('../models/post');
const User = require('../models/user');
const { validationResult } = require('express-validator');
const validator = require('validator');

module.exports = {
  // ... existing resolvers (createUser, login)

  createPost: async function({ postInput }, req) {
    if (!req.isAuth) {
      const error = new Error('Not authenticated!');
      error.code = 401;
      throw error;
    }

    const errors = [];
    if (validator.isEmpty(postInput.title) || !validator.isLength(postInput.title, { min: 5 })) {
      errors.push({ message: 'Title is invalid.' });
    }
    if (validator.isEmpty(postInput.content) || !validator.isLength(postInput.content, { min: 5 })) {
      errors.push({ message: 'Content is invalid.' });
    }
    if (errors.length > 0) {
      const error = new Error('Invalid input.');
      error.data = errors;
      error.code = 422;
      throw error;
    }

    const user = await User.findById(req.userId);
    if (!user) {
      const error = new Error('Invalid user.');
      error.code = 401;
      throw error;
    }

    const post = new Post({
      title: postInput.title,
      content: postInput.content,
      imageUrl: postInput.imageUrl,
      creator: user
    });

    const createdPost = await post.save();

    user.posts.push(createdPost);
    await user.save();

    return {
      ...createdPost._doc,
      _id: createdPost._id.toString(),
      createdAt: createdPost.createdAt.toISOString(),
      updatedAt: createdPost.updatedAt.toISOString()
    };
  }
};
```

---

### 3️⃣ **Middleware for Auth**

You should already have an `is-auth.js` middleware to set `req.isAuth` and `req.userId`. If not:

```js
const jwt = require('jsonwebtoken');

module.exports = (req, res, next) => {
  const authHeader = req.get('Authorization');
  if (!authHeader) {
    req.isAuth = false;
    return next();
  }
  const token = authHeader.split(' ')[1];
  if (!token || token === '') {
    req.isAuth = false;
    return next();
  }
  let decodedToken;
  try {
    decodedToken = jwt.verify(token, 'somesupersecretkey');
  } catch (err) {
    req.isAuth = false;
    return next();
  }
  if (!decodedToken) {
    req.isAuth = false;
    return next();
  }
  req.isAuth = true;
  req.userId = decodedToken.userId;
  next();
};
```

Attach it in `app.js`:

```js
app.use(isAuth);
```

---

## ✅ Frontend: Send Create Post Request

In your **React frontend**, inside the “create post” handler:

### 1️⃣ **Define the GraphQL Mutation**

```js
const graphqlQuery = {
  query: `
    mutation CreateNewPost($title: String!, $content: String!, $imageUrl: String!) {
      createPost(postInput: { title: $title, content: $content, imageUrl: $imageUrl }) {
        _id
        title
        content
        imageUrl
        creator {
          _id
          name
        }
        createdAt
      }
    }
  `,
  variables: {
    title: enteredTitle,
    content: enteredContent,
    imageUrl: 'https://dummyimage.com/600x400/000/fff' // Dummy for now
  }
};
```

---

### 2️⃣ **Send the Request**

```js
fetch('http://localhost:8080/graphql', {
  method: 'POST',
  headers: {
    'Content-Type': 'application/json',
    Authorization: 'Bearer ' + token  // Attach JWT token here
  },
  body: JSON.stringify(graphqlQuery)
})
  .then(res => {
    return res.json();
  })
  .then(resData => {
    if (resData.errors) {
      throw new Error('Post creation failed!');
    }
    console.log('Created Post:', resData.data.createPost);
  })
  .catch(err => {
    console.error(err);
  });
```

---

## 🚀 Test it

1. Go to **GraphiQL**:
    

```graphql
mutation {
  createPost(postInput: {
    title: "First Post",
    content: "This is my first post",
    imageUrl: "https://dummyimage.com/600x400/000/fff"
  }) {
    _id
    title
    content
    creator {
      name
    }
    createdAt
  }
}
```

Make sure you send a **valid JWT token** in the `Authorization` header.

2. Then test it in your frontend.
    

---

## 📌 Next Steps

✔ Connect **getPosts** query  
✔ Wire up posts list in frontend  
✔ Add real image upload (later)  
✔ Add pagination

---

Do you want me to:

✅ Write the **getPosts query & resolver** now (so frontend can fetch all posts)?  
✅ Or wire up the **frontend Create Post form** first?  
✅ Or both?

-------

Perfect, Cypher_X. You now have **secure post creation** working end-to-end on the backend! 🎯 Let’s break down what just happened and then move to the frontend.

---

### ✅ What we achieved so far:

1. **Create Post Mutation:**
    
    - Accepts a `PostInputData` type (title, content, imageUrl).
        
    - Validates the input for length and emptiness.
        
    - Creates a `Post` document with `creator` initially ignored.
        
2. **Auth Middleware:**
    
    - Checks for a token in the `Authorization` header.
        
    - Decodes it using JWT and attaches `isAuth` + `userId` to the request.
        
    - Doesn’t block requests but sets `isAuth = false` if no/invalid token.
        
3. **Updated Resolver (createPost):**
    
    - Checks `req.isAuth` → throws `401 Not authenticated` if false.
        
    - Loads user from DB with `req.userId`.
        
    - Throws `401 Invalid user` if user doesn’t exist.
        
    - Sets `creator` on the Post and also adds the Post to the user’s `posts` array for reverse population.
        

---

### 🔥 Next Step: Frontend Integration

Now let’s wire it up in the frontend (assuming you’re in `feed.js` or equivalent):

1. **In `finishEditHandler` (the function for creating/editing posts):**
    
    - Call your GraphQL API with the mutation.
        
    - Send the JWT token in the `Authorization` header.
        
    - Format the mutation properly.
        

```javascript
const graphqlQuery = {
  query: `
    mutation CreateNewPost($postInput: PostInputData!) {
      createPost(postInput: $postInput) {
        _id
        title
        content
        imageUrl
        creator {
          name
        }
        createdAt
      }
    }
  `,
  variables: {
    postInput: {
      title: postTitle,
      content: postContent,
      imageUrl: "https://dummyimage.com/placeholder.jpg", // placeholder
    }
  }
};

fetch('http://localhost:8080/graphql', {
  method: 'POST',
  headers: {
    Authorization: 'Bearer ' + localStorage.getItem('token'), // Send JWT here
    'Content-Type': 'application/json'
  },
  body: JSON.stringify(graphqlQuery)
})
  .then(res => {
    if (res.status !== 200 && res.status !== 201) {
      throw new Error('Creating a post failed!');
    }
    return res.json();
  })
  .then(resData => {
    console.log(resData);
    // Optionally update state or UI to show the new post
  })
  .catch(err => {
    console.error(err);
  });
```

---

### ✨ What’s cool about this

- Your backend now **securely ties every Post to the logged-in User**.
    
- Unauthorized users cannot post anything.
    
- Posts are **bi-directionally related** (`Post.creator` and `User.posts`).
    

---

### 🚀 Next Milestone

We can now:  
✅ Fetch posts per user (query with filtering).  
✅ Add pagination support.  
✅ Handle image uploads with a separate mutation (later).

---

Do you want me to:  
✅ Write out **the full GraphQL query + variables for testing in GraphiQL/Postman**?  
✅ Or jump **straight to frontend `finishEditHandler` full integration** with your existing React code?  
✅ Or BOTH (so you can test in GraphiQL before React)?