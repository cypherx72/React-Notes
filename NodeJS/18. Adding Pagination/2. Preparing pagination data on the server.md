You're now on the **final step** of building a **robust pagination system** in your Express + Mongoose app. So far, you've done this right:

- ‚úÖ Grabbed `page` from `req.query`.
    
- ‚úÖ Defined `ITEMS_PER_PAGE`.
    
- ‚úÖ Used `skip()` and `limit()` to fetch paginated data.
    
- ‚úÖ Used `countDocuments()` to get the total number of items.
    
- ‚úÖ Calculated and passed all relevant metadata: `hasNextPage`, `hasPreviousPage`, `nextPage`, `previousPage`, `lastPage`, `totalItems`.
    

Now it‚Äôs time to **render dynamic pagination controls** in your template (`index.ejs`, `index.pug`, or whatever you‚Äôre using). Here's how to go forward:

---

### üí° Rendering Dynamic Pagination in the View

#### ‚úÖ Example EJS Template Snippet

Let‚Äôs say you‚Äôre using EJS for your frontend. Inside your view:

```ejs
<div class="pagination">
  <% if (hasPreviousPage) { %>
    <a href="/?page=<%= previousPage %>">Previous</a>
  <% } %>

  <% for (let i = 1; i <= lastPage; i++) { %>
    <a href="/?page=<%= i %>" class="<%= i === currentPage ? 'active' : '' %>">
      <%= i %>
    </a>
  <% } %>

  <% if (hasNextPage) { %>
    <a href="/?page=<%= nextPage %>">Next</a>
  <% } %>
</div>
```

Add styles like `.active { font-weight: bold; }` to highlight the current page.

---

### üîÅ Full Controller Example (for clarity)

```js
const ITEMS_PER_PAGE = 2;

exports.getIndex = (req, res, next) => {
  const page = +req.query.page || 1;
  let totalItems;

  Product.find()
    .countDocuments()
    .then(numProducts => {
      totalItems = numProducts;
      return Product.find()
        .skip((page - 1) * ITEMS_PER_PAGE)
        .limit(ITEMS_PER_PAGE);
    })
    .then(products => {
      res.render('shop/index', {
        prods: products,
        currentPage: page,
        hasNextPage: ITEMS_PER_PAGE * page < totalItems,
        hasPreviousPage: page > 1,
        nextPage: page + 1,
        previousPage: page - 1,
        lastPage: Math.ceil(totalItems / ITEMS_PER_PAGE),
        totalItems: totalItems
      });
    })
    .catch(err => {
      console.log(err);
    });
};
```

---

### ‚úÖ Final Checklist

-  Frontend receives all pagination metadata.
    
-  Dynamic buttons render correctly for current/next/previous/last pages.
    
-  Your database fetch is efficient (using `skip()` + `limit()`).
    
-  Active page is visually highlighted.
    
-  Handles edge cases (empty pages, one-page only, out-of-bound queries).
    

---

### ‚ö†Ô∏è Gotchas to Avoid

- If `req.query.page` is not a number (like `?page=abc`), it will default to 1 with `+req.query.page || 1`‚Äîgood.
    
- Make sure `countDocuments()` matches your `.find()` query filter if you ever filter/search products (e.g., categories).
    
- Consider using query validation middleware in production.
    

---

Let me know if you want this extended to:

- Add **category filters**.
    
- Keep **filters/search terms** in the pagination links.
    
- Convert this to use **AJAX for client-side pagination**.
    

Want a visual pagination bar with icons/styling too? I can give you a full example.