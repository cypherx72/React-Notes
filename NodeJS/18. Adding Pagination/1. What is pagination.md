Here are your **core notes on implementing pagination** in a Node.js/Express + EJS web app (from-scratch version, no 3rd-party library):

---

## üîÅ **Core Concepts of Pagination**

### üí° Why Pagination?

- Improves **performance** by loading only a small set of records at a time.
    
- Enhances **user experience** with cleaner navigation and UI.
    
- Avoids overwhelming the client (and the server) when handling large datasets.
    

---

## üîó **Frontend Setup: Pagination Links in EJS**

### ‚úÖ Step 1: Add Pagination Controls in Template

Inside your `views/index.ejs` (or `shop.ejs`, wherever you're listing products):

```ejs
<section class="pagination">
  <a href="/?page=1">1</a>
  <a href="/?page=2">2</a>
</section>
```

### üé® Step 2: Optional Styling (`public/css/main.css`)

```css
.pagination {
  text-align: center;
  margin-top: 2rem;
}

.pagination a {
  text-decoration: none;
  color: #0e6f64; /* example green */
  padding: 0.5rem;
  border: 1px solid #0e6f64;
  margin: 0 1rem;
}

.pagination a:hover,
.pagination a:active {
  background-color: #0e6f64;
  color: white;
}
```

---

## üß† **Backend Logic: How Pagination Works**

### ‚úÖ Step 3: Accept Page Number via Query Param

Inside your controller or route handler (e.g., in `/routes/shop.js` or `/controllers/shop.js`):

```js
const ITEMS_PER_PAGE = 2;

exports.getIndex = (req, res, next) => {
  const page = +req.query.page || 1;

  let totalItems;

  Product.find()
    .countDocuments()
    .then(numProducts => {
      totalItems = numProducts;
      return Product.find()
        .skip((page - 1) * ITEMS_PER_PAGE)
        .limit(ITEMS_PER_PAGE);
    })
    .then(products => {
      res.render('shop/index', {
        prods: products,
        currentPage: page,
        hasNextPage: ITEMS_PER_PAGE * page < totalItems,
        hasPreviousPage: page > 1,
        nextPage: page + 1,
        previousPage: page - 1,
        lastPage: Math.ceil(totalItems / ITEMS_PER_PAGE)
      });
    })
    .catch(err => {
      console.log(err);
    });
};
```

---

## üìÑ **Rendering Dynamic Pagination Buttons**

Instead of hardcoding links like `1` and `2`, you can dynamically render them:

```ejs
<div class="pagination">
  <% if (hasPreviousPage) { %>
    <a href="/?page=<%= previousPage %>">Previous</a>
  <% } %>

  <% for (let i = 1; i <= lastPage; i++) { %>
    <a href="/?page=<%= i %>" class="<%= i === currentPage ? 'active' : '' %>"><%= i %></a>
  <% } %>

  <% if (hasNextPage) { %>
    <a href="/?page=<%= nextPage %>">Next</a>
  <% } %>
</div>
```

You can highlight the current page by adding a class `active` if `i === currentPage`.

---

## ‚öôÔ∏è **Key Parameters**

- `page`: current page from query string.
    
- `ITEMS_PER_PAGE`: how many products to show on each page.
    
- `skip()`: skip products before current page starts.
    
- `limit()`: limit result to current page‚Äôs worth of items.
    
- `countDocuments()`: total number of items to calculate total pages.
    

---

## ‚ö†Ô∏è Important Considerations

- Always **validate** the `page` parameter (e.g., must be a number ‚â• 1).
    
- You should **default** to page `1` if no page is provided.
    
- Be careful of **edge cases**: empty results, out-of-range pages.
    
- Add pagination to **search and filter** views too, if needed.
    

---

Great, you're now doing real backend pagination logic using `skip()` and `limit()` with Mongoose. This is textbook pagination done manually. Let's capture the **core notes** of what you've implemented and what's next.

---

### ‚úÖ **Core Concepts and Code for Pagination (Backend + Frontend)**

#### 1. **Pagination Trigger (Frontend via Query Params)**:

- You're using query parameters in the URL like:
    
    ```
    /?page=1
    /?page=2
    ```
    
- These are linked with anchor `<a>` tags:
    
    ```html
    <a href="/?page=1">1</a>
    <a href="/?page=2">2</a>
    ```
    

---

#### 2. **Pagination Controls (Frontend Styling)**:

- CSS class `pagination` centers the links and styles them.
    
- Example styles:
    
    ```css
    .pagination {
      text-align: center;
      margin-top: 2rem;
    }
    
    .pagination a {
      text-decoration: none;
      color: green;
      padding: 0.5rem;
      border: 1px solid green;
      margin: 0 1rem;
    }
    
    .pagination a:hover,
    .pagination a:active {
      background-color: green;
      color: white;
    }
    ```
    

---

#### 3. **Backend Handling with Mongoose**:

- Extract the `page` from the query string:
    
    ```js
    const page = +req.query.page || 1; // fallback to 1 if undefined
    ```
    
- Define a constant for items per page:
    
    ```js
    const ITEMS_PER_PAGE = 2;
    ```
    
- Paginate using Mongoose methods:
    
    ```js
    Product.find()
      .skip((page - 1) * ITEMS_PER_PAGE)
      .limit(ITEMS_PER_PAGE)
    ```
    

---

#### 4. **Logic Behind Skip and Limit**:

- `skip(n)` skips the first `n` items.
    
- `limit(n)` restricts to `n` items.
    
- Example:
    
    - On `page 1`: skip 0, limit 2 ‚Üí items 1 & 2
        
    - On `page 2`: skip 2, limit 2 ‚Üí items 3 & 4
        
    - On `page 3`: skip 4, limit 2 ‚Üí items 5 & 6
        

---

### üîú **What's Next? (Dynamic Pagination Buttons)**

Right now, your buttons (`1`, `2`, `3`, etc.) are hardcoded. That‚Äôs not scalable.

Here‚Äôs what to implement next:

#### Step 1: Get Total Product Count

In your controller:

```js
const totalProducts = await Product.countDocuments();
```

#### Step 2: Calculate `hasNextPage`, `hasPreviousPage`, and `lastPage`:

```js
const hasNextPage = ITEMS_PER_PAGE * page < totalProducts;
const hasPreviousPage = page > 1;
const lastPage = Math.ceil(totalProducts / ITEMS_PER_PAGE);
```

#### Step 3: Pass these to your template:

```js
res.render('index', {
  products: products,
  currentPage: page,
  hasNextPage,
  hasPreviousPage,
  nextPage: page + 1,
  previousPage: page - 1,
  lastPage
});
```

#### Step 4: Conditionally Render Page Controls in EJS:

```ejs
<div class="pagination">
  <% if (hasPreviousPage) { %>
    <a href="/?page=<%= previousPage %>">Previous</a>
  <% } %>

  <% for (let i = 1; i <= lastPage; i++) { %>
    <a href="/?page=<%= i %>" <%= i === currentPage ? 'style="font-weight: bold;"' : '' %>><%= i %></a>
  <% } %>

  <% if (hasNextPage) { %>
    <a href="/?page=<%= nextPage %>">Next</a>
  <% } %>
</div>
```

---

### ‚úÖ Summary

You‚Äôve:

- Used query parameters to drive pagination.
    
- Used `skip()` and `limit()` to control the fetched data.
    
- Styled basic pagination links.
    
- Next up: dynamically render pagination controls using total count + current page info.
    

This gives you clean, scalable pagination without needing external libraries. Once you‚Äôve implemented dynamic page numbers and next/prev logic, this will be fully production-ready.

Let me know when you're ready for the next level like:

- Disabling next/prev on first/last pages
    
- Jump-to-page dropdown
    
- Page size control (e.g., 10, 20, 50 per page)
    

Want code snippets for any of those?