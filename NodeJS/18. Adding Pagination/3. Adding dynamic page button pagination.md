Great ‚Äî what you've just implemented is **dynamic, intelligent pagination** using EJS and backend-driven logic. To recap and reinforce your understanding (and in case you want to extract this as documentation for future reuse), here‚Äôs a concise **breakdown of how your pagination system works** and what improvements were made:

---

### ‚úÖ **Core Improvements Implemented**

1. **Backend Changes (Express + MongoDB):**
    
    - `countDocuments()` used instead of deprecated `count()`.
        
    - `totalItems` is fetched first via `Product.countDocuments()`.
        
    - Products fetched with `.skip()` and `.limit()` for pagination control.
        
    - Additional pagination metadata is sent to the frontend:
        
        - `currentPage`
            
        - `hasNextPage`
            
        - `hasPreviousPage`
            
        - `nextPage`
            
        - `previousPage`
            
        - `lastPage` (calculated via `Math.ceil(totalItems / ITEMS_PER_PAGE)`)
            
2. **Frontend Changes (EJS):**
    
    - First page is always shown, **unless it's redundant** (i.e., already shown as current or previous page).
        
    - `currentPage` is marked with a CSS class (`active`) for visual distinction.
        
    - Next and Previous page links are **conditionally rendered**:
        
        - `hasNextPage` ‚Üí show `nextPage`
            
        - `hasPreviousPage` ‚Üí show `previousPage`
            
    - Last page is shown if current/next isn‚Äôt already the last.
        
    - Data type coercion fixed: `+req.query.page` ensures correct numeric operations.
        
    - Fallback to page `1` added with `|| 1`.
        

---

### üõ†Ô∏è **Logic Summary Pseudocode (Backend)**

```js
const ITEMS_PER_PAGE = 2;
const page = +req.query.page || 1;

let totalItems;

Product.find().countDocuments()
  .then(numProducts => {
    totalItems = numProducts;
    return Product.find()
      .skip((page - 1) * ITEMS_PER_PAGE)
      .limit(ITEMS_PER_PAGE);
  })
  .then(products => {
    res.render('shop/index', {
      products: products,
      currentPage: page,
      hasNextPage: ITEMS_PER_PAGE * page < totalItems,
      hasPreviousPage: page > 1,
      nextPage: page + 1,
      previousPage: page - 1,
      lastPage: Math.ceil(totalItems / ITEMS_PER_PAGE)
    });
  });
```

---

### üí° **Edge Case Handling**

- Missing `?page=` param defaults to page `1`.
    
- Prevents duplicate rendering of page 1 or last page when already active.
    
- Type coercion ensures numbers are not accidentally concatenated as strings (e.g., `"1" + 1 === "11"`).
    
- Styling is consistent with hover via `a.active` selector.
    

---

### üß© **Optional UX Enhancements You Could Add**

- **"..." Skipping Pages**: When you have 20+ pages, show something like `1 ... 5 6 [7] 8 9 ... 20`.
    
- **Items-per-page dropdown**: Let users choose how many items they want to view per page.
    
- **Keyboard navigation** (‚Üê / ‚Üí arrow keys for pagination).
    
- **Persistent URL query state** with `history.pushState` for SPA-like experience.
    
- **API support**: Convert this pagination logic into a JSON API that your frontend can consume asynchronously via fetch/AJAX.
    

---

### ‚úÖ Final Thoughts

You've implemented this the **right way** ‚Äî fetch minimal, show clean, control via backend, and render flexibly on the frontend. The key takeaway: you now **fully control pagination behavior** and can evolve this into infinite scroll, GraphQL cursor pagination, or SPA pagination with frameworks like React.

If you'd like, I can also help you abstract this into a reusable EJS pagination component. Want that?