
Got it üëç ‚Äî you want **clean notes** (like a study sheet / summary) for **deletion in linked lists**. I‚Äôll strip out the storytelling and keep it as crisp structured notes, while still detailed enough for revision.

---

# üìí Notes: Deletion in Linked List

### Cases in Deletion

1. **Deleting the First Node** (special case).
    
2. **Deleting a Node at a Given Position** (anywhere else).
    

---

## 1. Deleting the First Node

- **Steps**:
    
    1. Use an extra pointer `p` to hold the first node.
        
    2. Move `first` to `first->next`.
        
    3. Copy data if needed (for return value).
        
    4. Delete node `p` to free memory.
        
- **Code Snippet (C++ style)**:
    
    ```cpp
    int DeleteFirst(Node* &first) {
        Node* p = first;            // hold first
        int x = p->data;            // store data
        first = first->next;        // move first ahead
        delete p;                   // free memory
        return x;                   // return deleted value
    }
    ```
    
- **Analysis**:
    
    - Time complexity: **O(1)**
        
    - Extra pointer required: **1** (`p`)
        

---

## 2. Deleting a Node at a Given Position

- **Idea**:
    
    - To delete node at position `pos`, link the `(pos-1)`-th node to `(pos+1)`-th node.
        
    - Free memory of `pos`-th node.
        
- **Steps**:
    
    1. Take two pointers:
        
        - `p` ‚Üí moves to the node that will be deleted.
            
        - `q` ‚Üí follows behind `p`, points to the previous node.
            
    2. Move `p` to the `pos`-th node and `q` to `(pos-1)`-th node.
        
    3. Modify `q->next = p->next`.
        
    4. Save `p->data`, delete `p`.
        
- **Code Snippet (C++ style)**:
    
    ```cpp
    int Delete(Node* &first, int pos) {
        Node* p = first;
        Node* q = NULL;
        int x = -1;
    
        if (pos == 1) {   // case 1: delete first node
            return DeleteFirst(first);
        }
        else {
            for (int i = 0; i < pos-1 && p != NULL; i++) {
                q = p;
                p = p->next;
            }
            if (p != NULL) {
                q->next = p->next;   // bypass p
                x = p->data;         // store data
                delete p;            // free memory
            }
        }
        return x;  // return deleted value (or -1 if invalid)
    }
    ```
    
- **Analysis**:
    
    - Links modified: **1**
        
    - Extra pointers required: **2** (`p`, `q`)
        
    - Time complexity:
        
        - Best case (delete 2nd node): **O(1)**
            
        - Worst case (delete last node): **O(n)**
            

---

## ‚úÖ Key Points to Remember

- Always free memory of deleted node (heap deallocation).
    
- First node deletion is a **special case** (because `first` must move).
    
- Need **extra pointers** so we don‚Äôt lose access to rest of the list.
    
- Function should **return deleted value** (since deletion is not just ‚Äúthrow away‚Äù).
    

---

Here‚Äôs the **C code for deleting a node (first node or node at any given position) from a singly linked list**:

```c
#include <stdio.h>
#include <stdlib.h>

// Node structure
struct Node {
    int data;
    struct Node *next;
};

struct Node *first = NULL;  // Global head pointer

// Function to create a linked list from an array
void create(int A[], int n) {
    struct Node *t, *last;
    first = (struct Node *)malloc(sizeof(struct Node));
    first->data = A[0];
    first->next = NULL;
    last = first;

    for (int i = 1; i < n; i++) {
        t = (struct Node *)malloc(sizeof(struct Node));
        t->data = A[i];
        t->next = NULL;
        last->next = t;
        last = t;
    }
}

// Function to display the linked list
void display(struct Node *p) {
    while (p != NULL) {
        printf("%d -> ", p->data);
        p = p->next;
    }
    printf("NULL\n");
}

// Function to delete node at given position
int Delete(int pos) {
    struct Node *p, *q = NULL;
    int x = -1;

    // If deleting the first node
    if (pos == 1) {
        p = first;
        if (first != NULL) {
            x = first->data;
            first = first->next;
            free(p);
        }
        return x;
    } else {
        p = first;
        for (int i = 0; i < pos - 1 && p != NULL; i++) {
            q = p;
            p = p->next;
        }
        if (p != NULL) {
            q->next = p->next;
            x = p->data;
            free(p);
        }
        return x;
    }
}

int main() {
    int A[] = {3, 7, 9, 15, 20};
    create(A, 5);

    printf("Initial Linked List:\n");
    display(first);

    printf("\nDeleting 1st node: %d\n", Delete(1));
    display(first);

    printf("\nDeleting 3rd node: %d\n", Delete(3));
    display(first);

    printf("\nDeleting 10th node (invalid): %d\n", Delete(10));
    display(first);

    return 0;
}
```

---

### üîé Explanation:

1. **Case 1 ‚Äì Deleting the first node**
    
    - Save `first->data` into `x`.
        
    - Move `first` to `first->next`.
        
    - Free the old first node.
        
    - Return the deleted value.
        
2. **Case 2 ‚Äì Deleting any other node**
    
    - Use two pointers:
        
        - `p` (to traverse the list).
            
        - `q` (to follow `p`, pointing to the node just before `p`).
            
    - Move them until `p` points to the node to be deleted.
        
    - Re-link: `q->next = p->next`.
        
    - Free the node `p`.
        
3. **Edge cases handled**
    
    - If position is invalid (e.g., beyond the length of the list), function returns `-1`.
        

---

‚ö° Time Complexity:

- **O(1)** for deleting the first node.
    
- **O(pos)** for deleting node at position `pos`.
    
- Worst case ‚Üí O(n).
    

---

