Perfect ðŸ‘ Youâ€™ve got the **insertion in doubly linked list (DLL)** lecture script.  
Let me break it into **clear structured notes + pseudo-code** so itâ€™s easier to revise and implement later.

---

# ðŸ“˜ Notes: Insertion in Doubly Linked List

### Cases of Insertion

In a DLL with `n` nodes, there are **n+1 possible positions** for insertion:

- **Before first node** (index `0`)
    
- **Between existing nodes** (index `1` â€¦ `n-1`)
    
- **After last node** (index `n`)
    

---

## ðŸ”¹ Case 1: Insert Before First Node

Steps:

1. Create new node `T`
    
2. Set `T->data = value`
    
3. Modify links:
    
    - `T->prev = NULL`
        
    - `T->next = first`
        
    - `first->prev = T`
        
4. Move `first = T`
    

ðŸ‘‰ **Links modified = 3**

â± Time complexity = **O(1)** (constant)

---

## ðŸ”¹ Case 2: Insert at Any Other Position

Suppose inserting at **position k** (1-based, after k-th node):

1. Create new node `T` and set `T->data = value`
    
2. Traverse list with pointer `P` to reach (k-th node)
    
3. Modify links:
    
    - `T->next = P->next`
        
    - `T->prev = P`
        
    - If `P->next != NULL`, then `P->next->prev = T`
        
    - `P->next = T`
        

ðŸ‘‰ **Links modified = 3 or 4**

- If inserting at last: 3 links
    
- Else: 4 links
    

â± Time complexity:

- **O(1)** if inserting after head
    
- **O(n)** in worst case (insert after last node)
    

---

## ðŸ”¹ Edge Cases

- **Empty DLL**: inserting first node â†’ just set `first = T`, and `T->prev = T->next = NULL`.
    
- **Insert at tail**: same as general case, except `P->next` is `NULL`.
    

---

## ðŸ”¹ C Code Snippet

```c
struct Node {
    struct Node *prev;
    int data;
    struct Node *next;
};

struct Node *first = NULL;

void insert(int pos, int value) {
    struct Node *T, *P;
    int i;

    T = (struct Node*)malloc(sizeof(struct Node));
    T->data = value;
    T->prev = T->next = NULL;

    // Case 1: insert before first
    if (pos == 0) {
        T->next = first;
        if (first != NULL) first->prev = T;
        first = T;
    } else {
        P = first;
        for (i = 0; i < pos-1 && P != NULL; i++)
            P = P->next;

        if (P != NULL) {
            T->next = P->next;
            T->prev = P;
            if (P->next != NULL)
                P->next->prev = T;
            P->next = T;
        }
    }
}
```

---

## ðŸ”¹ Analysis

- **Pointers needed**:
    
    - Insert before first â†’ 1 temp pointer
        
    - Insert elsewhere â†’ 2 pointers (`P` + `T`)
        
- **Links modified**:
    
    - Before first â†’ 3
        
    - Between nodes â†’ 4
        
    - At last â†’ 3
        
- **Time Complexity**:
    
    - Min = O(1) (head insertion)
        
    - Max = O(n) (tail insertion)
        

---

ðŸ‘‰ So DLL insertion is flexible:  
Head insertion is fastest, middle/tail insertion depends on traversal cost.

---

Do you want me to also prepare a **delete operation in DLL (with full code)** next, so youâ€™ll have both **insert + delete** cleanly documented?