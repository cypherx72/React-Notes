Perfect 👍 You’ve got the **insertion in doubly linked list (DLL)** lecture script.  
Let me break it into **clear structured notes + pseudo-code** so it’s easier to revise and implement later.

---

# 📘 Notes: Insertion in Doubly Linked List

### Cases of Insertion

In a DLL with `n` nodes, there are **n+1 possible positions** for insertion:

- **Before first node** (index `0`)
    
- **Between existing nodes** (index `1` … `n-1`)
    
- **After last node** (index `n`)
    

---

## 🔹 Case 1: Insert Before First Node

Steps:

1. Create new node `T`
    
2. Set `T->data = value`
    
3. Modify links:
    
    - `T->prev = NULL`
        
    - `T->next = first`
        
    - `first->prev = T`
        
4. Move `first = T`
    

👉 **Links modified = 3**

⏱ Time complexity = **O(1)** (constant)

---

## 🔹 Case 2: Insert at Any Other Position

Suppose inserting at **position k** (1-based, after k-th node):

1. Create new node `T` and set `T->data = value`
    
2. Traverse list with pointer `P` to reach (k-th node)
    
3. Modify links:
    
    - `T->next = P->next`
        
    - `T->prev = P`
        
    - If `P->next != NULL`, then `P->next->prev = T`
        
    - `P->next = T`
        

👉 **Links modified = 3 or 4**

- If inserting at last: 3 links
    
- Else: 4 links
    

⏱ Time complexity:

- **O(1)** if inserting after head
    
- **O(n)** in worst case (insert after last node)
    

---

## 🔹 Edge Cases

- **Empty DLL**: inserting first node → just set `first = T`, and `T->prev = T->next = NULL`.
    
- **Insert at tail**: same as general case, except `P->next` is `NULL`.
    

---

## 🔹 C Code Snippet

```c
struct Node {
    struct Node *prev;
    int data;
    struct Node *next;
};

struct Node *first = NULL;

void insert(int pos, int value) {
    struct Node *T, *P;
    int i;

    T = (struct Node*)malloc(sizeof(struct Node));
    T->data = value;
    T->prev = T->next = NULL;

    // Case 1: insert before first
    if (pos == 0) {
        T->next = first;
        if (first != NULL) first->prev = T;
        first = T;
    } else {
        P = first;
        for (i = 0; i < pos-1 && P != NULL; i++)
            P = P->next;

        if (P != NULL) {
            T->next = P->next;
            T->prev = P;
            if (P->next != NULL)
                P->next->prev = T;
            P->next = T;
        }
    }
}
```

---

## 🔹 Analysis

- **Pointers needed**:
    
    - Insert before first → 1 temp pointer
        
    - Insert elsewhere → 2 pointers (`P` + `T`)
        
- **Links modified**:
    
    - Before first → 3
        
    - Between nodes → 4
        
    - At last → 3
        
- **Time Complexity**:
    
    - Min = O(1) (head insertion)
        
    - Max = O(n) (tail insertion)
        

---

👉 So DLL insertion is flexible:  
Head insertion is fastest, middle/tail insertion depends on traversal cost.

---

Do you want me to also prepare a **delete operation in DLL (with full code)** next, so you’ll have both **insert + delete** cleanly documented?