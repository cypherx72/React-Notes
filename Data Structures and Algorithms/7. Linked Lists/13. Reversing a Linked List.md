

---

# ðŸ“’ Notes:

## ðŸ”¹ What is Reversing?

- Reversing a linked list means changing the order of nodes.  
    Example: `2 â†’ 4 â†’ 6 â†’ 8` becomes `8 â†’ 6 â†’ 4 â†’ 2`.
    

---

## ðŸ”¹ Two Methods of Reversing

### 1. **Reversing Elements**

- Swap the **data values** of nodes (not links).
    
- Example: Value at first node (`2`) is swapped with last node (`8`), and so on.
    
- **Implementation idea:**
    
    1. Copy all elements into an **auxiliary array**.
        
    2. Then **reverse copy** back into the linked list.
        
- Example steps:
    
    - Original list: `2 4 6 8`
        
    - Copy to array: `[2, 4, 6, 8]`
        
    - Reverse copy back: `8 6 4 2`
        
- **Drawback:** Requires **extra O(n) space** for the array.
    
- **Time Complexity:** O(n) (two passes â†’ copy to array + copy back).
    
    

---

## ðŸ”¹ Algorithm: Reversing by Elements (Using Array)

1. Take an array of size = number of elements in linked list.
    
2. Traverse the linked list and copy data into the array.
    
3. Re-traverse the linked list, copying elements back in reverse order.
    

**Pseudocode:**

```c
p = head;  
i = 0;  
while (p != NULL) {
    A[i] = p->data;
    p = p->next;
    i++;
}

p = head;  
i = i - 1;  
while (p != NULL) {
    p->data = A[i];
    p = p->next;
    i--;
}
```

**Complexity:**

- Time = O(n) + O(n) = O(n)
    
- Space = O(n) (for array)
    


---

# 2. Reversing a Linked List by Reversing Links

## ðŸ”¹ Idea

- Instead of swapping **node data**, we reverse the **links** between nodes.
    
- Example: `2 â†’ 4 â†’ 6 â†’ 8` becomes `8 â†’ 6 â†’ 4 â†’ 2` by redirecting the `next` pointers.
    

---

## ðŸ”¹ Sliding Pointers Concept

We use **three pointers**:

1. **P** â†’ current node (moving forward)
    
2. **Q** â†’ previous node (the one whose link is being modified)
    
3. **R** â†’ node before Q (used for tracking backward link)
    

### Sliding Rule:

- `R = Q`
    
- `Q = P`
    
- `P = P->next`
    

This "slides" all three pointers forward one step.

---

## ðŸ”¹ Steps for Reversing Links

1. Initialize:
    
    - `P = head`
        
    - `Q = NULL`
        
    - `R = NULL`
        
2. While `P != NULL`:
    
    - Slide pointers (`R = Q; Q = P; P = P->next`)
        
    - Reverse the link: `Q->next = R`
        
3. At the end:
    
    - `head = Q` (last node becomes the new head).
        

---

## ðŸ”¹ Pseudocode

```c
Node* reverse(Node* head) {
    Node *P = head;
    Node *Q = NULL;
    Node *R = NULL;

    while (P != NULL) {
        // Slide pointers
        R = Q;
        Q = P;
        P = P->next;

        // Reverse the link
        Q->next = R;
    }

    // New head
    head = Q;
    return head;
}
```

---

## ðŸ”¹ Tracing Example

Original: `2 â†’ 4 â†’ 6 â†’ 8 â†’ NULL`

- Step 1: `2 â†’ NULL`, Q=2
    
- Step 2: `4 â†’ 2 â†’ NULL`, Q=4
    
- Step 3: `6 â†’ 4 â†’ 2 â†’ NULL`, Q=6
    
- Step 4: `8 â†’ 6 â†’ 4 â†’ 2 â†’ NULL`, Q=8
    

Final head = node with value **8**. âœ…

---

## ðŸ”¹ Why Prefer Reversing Links (Not Data)?

- A node may store **large records** (e.g., roll no, name, address, phone).
    
- Copying/swapping data would be expensive (maybe 200+ bytes).
    
- Reversing links only modifies **pointers** (just 2â€“4 bytes).
    
- Much more efficient, cleaner, and standard.
    

---

âœ… **Summary:**  
Reversing a linked list by links requires **3 pointers (P, Q, R)**.  
We slide them step by step and reverse each link.  
Time Complexity = **O(n)**, Space = **O(1)**.  
This is the **preferred method** in practice.

---


Perfect â€” you just described the **recursive reverse of a linked list** step by step. Let me structure it into **clear notes** and then give you the **C code implementation**.

---

## ðŸ“’ Notes: Recursive Reversal of Linked List

1. **Concept of Recursion**
    
    - Recursion has two phases:
        
        - **Calling phase** â†’ going deeper into the function.
            
        - **Returning phase** â†’ unwinding the stack, executing operations.
            
    - For reversing a linked list, we reverse **during the returning phase**, not the calling phase.
        
2. **Why Returning Phase?**
    
    - If we reverse while going forward, we lose access to the next nodes.
        
    - By returning, we already know where the "next" node is, so we can safely reverse the link.
        
3. **Pointers Used**
    
    - `P` â†’ current node (moves forward).
        
    - `Q` â†’ previous node (follows behind `P`).
        
4. **Base Case**
    
    - When `P == NULL`, it means we've reached the end of the list.
        
    - At this point, we make `first = Q` (update head pointer).
        
5. **Recursive Step**
    
    - Keep moving forward: `reverse(P, Q)` â†’ next recursive call.
        
    - While returning: set `P->next = Q` to reverse the link.
        
6. **Time Complexity**
    
    - Each node is visited once â†’ **O(n)**.
        
7. **Space Complexity**
    
    - Due to recursion stack â†’ **O(n)**.
        

---

## âœ… C Program: Recursive Reverse of Linked List

```c
#include <stdio.h>
#include <stdlib.h>

struct Node {
    int data;
    struct Node* next;
} *first = NULL;

// Function to create a linked list from array
void create(int A[], int n) {
    struct Node *t, *last;
    int i;

    first = (struct Node*)malloc(sizeof(struct Node));
    first->data = A[0];
    first->next = NULL;
    last = first;

    for(i = 1; i < n; i++) {
        t = (struct Node*)malloc(sizeof(struct Node));
        t->data = A[i];
        t->next = NULL;
        last->next = t;
        last = t;
    }
}

// Recursive reverse function
void Reverse(struct Node *q, struct Node *p) {
    if(p != NULL) {
        Reverse(p, p->next);   // Calling phase (go forward)
        p->next = q;           // Returning phase (reverse link)
    } else {
        first = q;  // When p becomes NULL, set head to last node
    }
}

// Function to display linked list
void Display(struct Node *p) {
    while(p != NULL) {
        printf("%d ", p->data);
        p = p->next;
    }
    printf("\n");
}

// Driver code
int main() {
    int A[] = {10, 20, 30, 40, 50};
    create(A, 5);

    printf("Original Linked List: ");
    Display(first);

    Reverse(NULL, first);

    printf("Reversed Linked List: ");
    Display(first);

    return 0;
}
```

---

### ðŸ”‘ Example Output:

```
Original Linked List: 10 20 30 40 50
Reversed Linked List: 50 40 30 20 10
```

---

Would you like me to also **contrast the recursive method with the iterative reversal** (using 3 pointers `prev`, `curr`, `next`) so you see both approaches side by side?