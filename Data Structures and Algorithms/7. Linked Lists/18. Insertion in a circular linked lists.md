Got it ðŸ‘ â€” here are **short, clear notes** based on the transcript about **Insertion in Circular Linked List**:

---

## **Insertion in a Circular Linked List**

### **Positions for insertion**

If there are `n` nodes, you can insert at:

- **Index 0** â†’ Before head node
    
- **Index 1 to n-1** â†’ Between nodes
    
- **Index n** â†’ After last node (same as before head)
    

So, total `n+1` positions are possible.

---

### **Two main cases**

#### 1. **Insert at any given position (other than head)**

- Create a new node `t` and assign data.
    
- Traverse from `head` using pointer `p` to `position - 1`.
    
- Adjust links:
    
    - `t->next = p->next`
        
    - `p->next = t`
        

ðŸ‘‰ This is **same as linear linked list insertion**.

- **Time Complexity**:
    
    - Best case (after head): **O(1)**
        
    - Worst case (after last node): **O(n)**
        

---

#### 2. **Insert before head (index 0)**

- Create new node `t` and assign data.
    
- Set `t->next = head`.
    
- Find the **last node** (whose `next == head`) using pointer `p`.
    
- Make `p->next = t`.
    
- Optionally, update `head = t` (depending on whether you want to move head).
    

ðŸ‘‰ Inserting **before head** = inserting **after last node**.

- **Special case**:
    
    - If list is empty (`head == NULL`):
        
        - Set `head = t` and `t->next = t`.
            

---

### **Combined Insert Function (logic)**

1. If position == 0 â†’ handle case of empty list OR insert before head.
    
2. Else â†’ traverse to `(position - 1)` and insert normally.
    

---

### **Complexity Analysis**

- **Insert after head** â†’ **O(1)** (constant time).
    
- **Insert before head / after last** â†’ **O(n)**.
    
- **Insert at general position** â†’ **O(n)**.
    

---

âœ… **Key takeaway**: In circular linked list, all insertions are similar to linear linked list, except for handling `head` and circular connections.

---

Do you want me to also **summarize this into pseudo-code** (like a small algorithm) so you can quickly revise without looking at full C code?