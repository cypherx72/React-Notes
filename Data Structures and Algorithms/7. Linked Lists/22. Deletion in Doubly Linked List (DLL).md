
---

# ðŸ“˜ Notes: Deletion in Doubly Linked List (DLL)

### Two Cases

1. **Delete First Node** (special case)
    
2. **Delete Node at Given Position (index)** (general case)
    

---

## ðŸ”¹ Case 1: Delete First Node

Steps:

1. Take pointer `P = first`.
    
2. Move `first = first->next`.
    
3. If `first != NULL`, then set `first->prev = NULL`.
    
4. Take out value `x = P->data`.
    
5. Free node `P`.
    

ðŸ‘‰ **Time Complexity = O(1)** (constant)

---

## ðŸ”¹ Case 2: Delete Node at Given Position `pos`

Steps:

1. Traverse to `pos`-th node with pointer `P`.
    
    - `P = first; for(i=0; i<pos-1; i++) P = P->next;`
        
2. Modify links:
    
    - `P->prev->next = P->next`
        
    - If `P->next != NULL`, then `P->next->prev = P->prev`
        
3. Take out value `x = P->data`.
    
4. Free node `P`.
    

ðŸ‘‰ **Time Complexity = O(pos)**

- Min = **O(1)** (delete second node)
    
- Max = **O(n)** (delete last node)
    

---

## ðŸ”¹ C Implementation

```c
struct Node {
    struct Node *prev;
    int data;
    struct Node *next;
};

struct Node *first = NULL;

int Delete(int pos) {
    struct Node *P;
    int x = -1, i;

    if (first == NULL) return -1;  // empty list

    // Case 1: delete first node
    if (pos == 1) {
        P = first;
        first = first->next;
        if (first != NULL) first->prev = NULL;
        x = P->data;
        free(P);
        return x;
    }

    // Case 2: delete at given position
    P = first;
    for (i = 0; i < pos-1 && P != NULL; i++)
        P = P->next;

    if (P != NULL) {
        P->prev->next = P->next;
        if (P->next != NULL)
            P->next->prev = P->prev;
        x = P->data;
        free(P);
    }

    return x;
}
```

---

## ðŸ”¹ Analysis

- **Pointers used**: Only one (`P`)
    
- **Links modified**:
    
    - Delete first â†’ 1 link (prev of new head)
        
    - Delete middle â†’ 2 links (prev + next)
        
    - Delete last â†’ 1 link
        
- **Time complexity**:
    
    - Head deletion â†’ O(1)
        
    - Any other node â†’ O(n) in worst case (traverse)
        

---

âœ… So DLL deletion is also flexible:

- **Fast at head**
    
- **Slower in middle/tail** (depends on traversal)
    

---

Do you want me to now make a **side-by-side summary table (Insertion vs Deletion in DLL)** so you can revise both at a glance?