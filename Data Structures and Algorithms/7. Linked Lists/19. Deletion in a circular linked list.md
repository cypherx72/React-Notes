
---

# Deletion in a Circular Linked List

We consider **1-based positions**:

- **Position 1** = head (first node)
    
- **Position k > 1** = any other node
    

## Case A: Delete at a given position (k > 1)

**Idea:** Link the node before the target to the node after the target, then free the target.

**Steps:**

1. If `head == NULL`: nothing to delete.
    
2. Move pointer `p` from `head` to the **(k−1)th** node  
    (loop `k-2` times: `p = p->next`, stop when `p->next == head` or done).
    
3. `q = p->next` (the kth node to remove).
    
4. Relink: `p->next = q->next`.
    
5. Optionally capture data: `x = q->data`.
    
6. `free(q)`.
    

**Time:**

- Best (k = 2): **O(1)**
    
- Worst (near “last”): **O(n)**
    

---

## Case B: Delete the head (position 1)

**Goal:** Make the next node the new head; ensure the **last node** points to this new head.

**Steps:**

1. If `head == NULL`: nothing to delete.
    
2. **Single-node case:** if `head->next == head`
    
    - Save data if needed, `free(head)`, set `head = NULL`. Done.
        
3. **General case:** find the **last node** `p` such that `p->next == head`.
    
4. Set `p->next = head->next`.
    
5. Save data if needed; `temp = head`; set `head = head->next`; `free(temp)`.
    

**Time:** **O(n)** (because you must find the last node).

> Tip: If you maintain a **tail pointer** (`tail` where `tail->next == head`), deleting head becomes **O(1)**:
> 
> ```
> if head == NULL: return
> if head->next == head: free(head); head = NULL; tail = NULL
> else: tail->next = head->next; temp = head; head = head->next; free(temp)
> ```

---

## Validations & Edge Cases

- **Empty list** (`head == NULL`) → no-op.
    
- **Invalid position** (`k <= 0` or `k > length`) → handle as error/ignore.
    
- **Traversal safety:** While moving `p`, stop if you wrap back to `head` before reaching target.
    

---

## Pseudocode (concise)

```c
// Delete node at 1-based position k
void deleteAtPos(Node **headRef, int k) {
    Node *head = *headRef;
    if (!head) return;

    // Delete head
    if (k == 1) {
        if (head->next == head) {           // single node
            free(head);
            *headRef = NULL;
            return;
        }
        // find last
        Node *p = head;
        while (p->next != head) p = p->next;
        p->next = head->next;
        Node *temp = head;
        *headRef = head->next;
        free(temp);
        return;
    }

    // Delete at k > 1
    Node *p = head;
    for (int i = 0; i < k - 2; i++) {
        p = p->next;
        if (p->next == head) return; // k out of range
    }
    Node *q = p->next;
    if (q == head) return;           // k out of range (wrapped)
    p->next = q->next;
    free(q);
}
```

**Key takeaways**

- Deleting **head** requires updating the **last node’s** `next`.
    
- Without a stored tail, head deletion is **O(n)**; with a tail, it’s **O(1)**.
    
- For **k > 1**, it’s the same pattern as a linear list, but watch for wrap-around.