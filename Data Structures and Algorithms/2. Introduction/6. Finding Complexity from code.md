Great â€” this is the **next natural step after introducing complexity**: actually teaching students _how to extract time complexity directly from code_. The raw transcript youâ€™ve written is thorough, but as a teaching script it needs **tightening, structure, and pacing** so learners donâ€™t get lost in the details.

Hereâ€™s how Iâ€™d recommend turning it into a crisp video-ready lesson:

---

## ğŸ¥ Video Script Outline: _Finding Complexity from Code_

---

### **1. Hook**

- Start with the big question:
    
    > â€œOkay, now that we know what complexity is, how do we actually find it from code? Letâ€™s learn a simple step-by-step way to analyze programs.â€
    

---

### **2. Assumption (Base Rule)**

- **Rule:** every _simple statement_ (assignment, arithmetic, condition, return) takes **1 unit of time**.
    
- If itâ€™s more complex â†’ break it down.
    
- Analogy: like counting â€œ1 stepâ€ for each instruction in cooking.
    

---

### **3. Example 1: Swap Function**

- Code (pseudocode):
    
    ```c
    void swap(x, y) {
        temp = x;
        x = y;
        y = temp;
    }
    ```
    
- Each statement = 1 unit. Total = 3.
    
- f(n) = 3 â†’ O(1).
    
- âœ… Key Point: constants â†’ **O(1)**.
    

---

### **4. Example 2: Summing Array**

- Code:
    
    ```c
    int sum(int A[], int n) {
        s = 0;
        for(i=0; i<n; i++) {
            s = s + A[i];
        }
        return s;
    }
    ```
    
- Breakdown:
    
    - Init (`s=0`) = 1.
        
    - Loop condition check ~ n+1.
        
    - Update (`s = s + A[i]`) â†’ n.
        
    - Return â†’ 1.
        
- f(n) = 2n + 3 â†’ O(n).
    
- âœ… Takeaway: single loop â†’ **O(n)**.
    

---

### **5. Example 3: Nested Loops**

- Code:
    
    ```c
    for(i=0; i<n; i++) {
        for(j=0; j<n; j++) {
            // simple statement
        }
    }
    ```
    
- Outer loop runs n times, inner loop runs n times per outer â†’ n Ã— n = nÂ².
    
- f(n) = nÂ² + â€¦ (lower terms ignored) â†’ O(nÂ²).
    
- âœ… Key Point: nested loops multiply â†’ **O(nÂ²), O(nÂ³)** etc.
    

---

### **6. Function Calls**

- Important clarification:
    
    - If `fun1()` calls `fun2()`, then **fun1â€™s complexity includes fun2â€™s complexity**.
        
    - Example:
        
        ```c
        fun1() {
            fun2();
        }
        fun2() {
            for(i=0; i<n; i++) {...}
        }
        ```
        
        - `fun2()` = O(n).
            
        - So `fun1()` = O(n).
            
- âœ… Lesson: always analyze _what the called function does_, not just the call itself.
    

---

### **7. Loops â†’ Complexity Patterns**

- **For loop (0 â†’ n)** â†’ O(n).
    
- **Nested loops** â†’ multiply complexities.
    
- **Divide by 2 each time** â†’ O(log n).
    
- **Combination** â†’ O(n log n), etc.
    
- âœ… Rule of Thumb: _Look at loops first. They usually dominate._
    

---

### **8. Wrap-up**

- Summarize the process:
    
    1. Break program into statements.
        
    2. Assign 1 unit for each simple statement.
        
    3. Multiply by number of times loop runs.
        
    4. Add them all â†’ time function f(n).
        
    5. Keep the highest degree term â†’ Big-O.
        
- End with confidence booster:
    
    > â€œThatâ€™s it! With a little practice, youâ€™ll be able to glance at code and immediately tell whether itâ€™s O(1), O(n), O(nÂ²), or more.â€
    

---

âš¡ This cleaned-up flow removes repetition and makes sure every example builds on the previous one:

- Start simple â†’ add loop â†’ add nested loop â†’ add function call.
    

---

Would you like me to also **prepare a storyboard version** (scene-by-scene visuals: e.g., showing code on screen, highlighting loops, animating n iterations), like we discussed for ADTs and time complexity? That would make this _directly usable for recording_.