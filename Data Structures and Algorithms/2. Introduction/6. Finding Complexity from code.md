Great — this is the **next natural step after introducing complexity**: actually teaching students _how to extract time complexity directly from code_. The raw transcript you’ve written is thorough, but as a teaching script it needs **tightening, structure, and pacing** so learners don’t get lost in the details.

Here’s how I’d recommend turning it into a crisp video-ready lesson:

---

## 🎥 Video Script Outline: _Finding Complexity from Code_

---

### **1. Hook**

- Start with the big question:
    
    > “Okay, now that we know what complexity is, how do we actually find it from code? Let’s learn a simple step-by-step way to analyze programs.”
    

---

### **2. Assumption (Base Rule)**

- **Rule:** every _simple statement_ (assignment, arithmetic, condition, return) takes **1 unit of time**.
    
- If it’s more complex → break it down.
    
- Analogy: like counting “1 step” for each instruction in cooking.
    

---

### **3. Example 1: Swap Function**

- Code (pseudocode):
    
    ```c
    void swap(x, y) {
        temp = x;
        x = y;
        y = temp;
    }
    ```
    
- Each statement = 1 unit. Total = 3.
    
- f(n) = 3 → O(1).
    
- ✅ Key Point: constants → **O(1)**.
    

---

### **4. Example 2: Summing Array**

- Code:
    
    ```c
    int sum(int A[], int n) {
        s = 0;
        for(i=0; i<n; i++) {
            s = s + A[i];
        }
        return s;
    }
    ```
    
- Breakdown:
    
    - Init (`s=0`) = 1.
        
    - Loop condition check ~ n+1.
        
    - Update (`s = s + A[i]`) → n.
        
    - Return → 1.
        
- f(n) = 2n + 3 → O(n).
    
- ✅ Takeaway: single loop → **O(n)**.
    

---

### **5. Example 3: Nested Loops**

- Code:
    
    ```c
    for(i=0; i<n; i++) {
        for(j=0; j<n; j++) {
            // simple statement
        }
    }
    ```
    
- Outer loop runs n times, inner loop runs n times per outer → n × n = n².
    
- f(n) = n² + … (lower terms ignored) → O(n²).
    
- ✅ Key Point: nested loops multiply → **O(n²), O(n³)** etc.
    

---

### **6. Function Calls**

- Important clarification:
    
    - If `fun1()` calls `fun2()`, then **fun1’s complexity includes fun2’s complexity**.
        
    - Example:
        
        ```c
        fun1() {
            fun2();
        }
        fun2() {
            for(i=0; i<n; i++) {...}
        }
        ```
        
        - `fun2()` = O(n).
            
        - So `fun1()` = O(n).
            
- ✅ Lesson: always analyze _what the called function does_, not just the call itself.
    

---

### **7. Loops → Complexity Patterns**

- **For loop (0 → n)** → O(n).
    
- **Nested loops** → multiply complexities.
    
- **Divide by 2 each time** → O(log n).
    
- **Combination** → O(n log n), etc.
    
- ✅ Rule of Thumb: _Look at loops first. They usually dominate._
    

---

### **8. Wrap-up**

- Summarize the process:
    
    1. Break program into statements.
        
    2. Assign 1 unit for each simple statement.
        
    3. Multiply by number of times loop runs.
        
    4. Add them all → time function f(n).
        
    5. Keep the highest degree term → Big-O.
        
- End with confidence booster:
    
    > “That’s it! With a little practice, you’ll be able to glance at code and immediately tell whether it’s O(1), O(n), O(n²), or more.”
    

---

⚡ This cleaned-up flow removes repetition and makes sure every example builds on the previous one:

- Start simple → add loop → add nested loop → add function call.
    

---

Would you like me to also **prepare a storyboard version** (scene-by-scene visuals: e.g., showing code on screen, highlighting loops, animating n iterations), like we discussed for ADTs and time complexity? That would make this _directly usable for recording_.