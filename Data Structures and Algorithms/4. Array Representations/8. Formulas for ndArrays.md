Perfect â€” youâ€™ve just walked through the **systematic derivation of row-major and column-major formulas** for **multi-dimensional arrays**, and then generalized it to _n dimensions_. Let me tidy this up into a structured reference so itâ€™s crystal clear.

---

## ğŸ”¹ 4D Array Address Mapping

Let array `A[d1][d2][d3][d4]` with element size `w` (bytes) and base address `L0`.

### **Row-major (C/C++ style, left â†’ right)**

LOC(A[i1][i2][i3][i4])=L0+(i1â‹…(d2d3d4)+i2â‹…(d3d4)+i3â‹…(d4)+i4)â‹…wLOC(A[i_1][i_2][i_3][i_4]) = L_0 + \Big( i_1 \cdot (d_2 d_3 d_4) + i_2 \cdot (d_3 d_4) + i_3 \cdot (d_4) + i_4 \Big) \cdot w

---

### **Column-major (Fortran/MATLAB style, right â†’ left)**

LOC(A[i1][i2][i3][i4])=L0+(i4â‹…(d1d2d3)+i3â‹…(d1d2)+i2â‹…(d1)+i1)â‹…wLOC(A[i_1][i_2][i_3][i_4]) = L_0 + \Big( i_4 \cdot (d_1 d_2 d_3) + i_3 \cdot (d_1 d_2) + i_2 \cdot (d_1) + i_1 \Big) \cdot w

---

## ğŸ”¹ General Formula for n Dimensions

Array: `A[d1][d2]...[dn]`  
Element: `A[i1][i2]...[in]`

---

### **Row-major (left â†’ right)**

LOC(A[i1,i2,â€¦,in])=L0+(âˆ‘p=1n(ipâ‹…âˆq=p+1ndq))â‹…wLOC(A[i_1,i_2,\dots,i_n]) = L_0 + \Bigg( \sum_{p=1}^{n} \Big( i_p \cdot \prod_{q=p+1}^{n} d_q \Big) \Bigg) \cdot w

ğŸ‘‰ Each index `ip` is multiplied by the product of all dimensions _after it_.

---

### **Column-major (right â†’ left)**

LOC(A[i1,i2,â€¦,in])=L0+(âˆ‘p=1n(ipâ‹…âˆq=1pâˆ’1dq))â‹…wLOC(A[i_1,i_2,\dots,i_n]) = L_0 + \Bigg( \sum_{p=1}^{n} \Big( i_p \cdot \prod_{q=1}^{p-1} d_q \Big) \Bigg) \cdot w

ğŸ‘‰ Each index `ip` is multiplied by the product of all dimensions _before it_.

---

## ğŸ”¹ Multiplication Complexity

- **NaÃ¯ve expansion** â†’ requires
    

n(nâˆ’1)2multiplicationsÂ (O(nÂ²))\frac{n(n-1)}{2} \quad \text{multiplications (O(nÂ²))}

- **After applying Hornerâ€™s Rule** â†’ only
    

nâˆ’1multiplicationsÂ (O(n))n-1 \quad \text{multiplications (O(n))}

âœ… Big win: modern compilers _always_ implement the optimized **Hornerâ€™s Rule form** internally.

---

## ğŸ”¹ Optimized Row-Major Formula (Hornerâ€™s Rule)

OFFSET=(((i1â‹…d2+i2)â‹…d3+i3)â‹…d4+i4)â‹…wOFFSET = (((i_1 \cdot d_2 + i_2) \cdot d_3 + i_3) \cdot d_4 + i_4) \cdot w

Generalized:

OFFSET=(((i1â‹…d2+i2)â‹…d3+i3)â€¦dn+in)â‹…wOFFSET = (((i_1 \cdot d_2 + i_2) \cdot d_3 + i_3) \dots d_n + i_n) \cdot w

---

âœ… So the rule of thumb:

- **Row-major** = build expression **left to right** (outermost index has biggest weight).
    
- **Column-major** = build expression **right to left** (innermost index has biggest weight).
    

---

Would you like me to also **draw a worked-out 3D example (say 2Ã—3Ã—4)** in both row-major and column-major layouts so you can _see the memory mapping step-by-step_ the same way we did with 2D?