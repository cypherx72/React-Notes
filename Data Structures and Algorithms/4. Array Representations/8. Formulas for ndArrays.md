Perfect — you’ve just walked through the **systematic derivation of row-major and column-major formulas** for **multi-dimensional arrays**, and then generalized it to _n dimensions_. Let me tidy this up into a structured reference so it’s crystal clear.

---

## 🔹 4D Array Address Mapping

Let array `A[d1][d2][d3][d4]` with element size `w` (bytes) and base address `L0`.

### **Row-major (C/C++ style, left → right)**

LOC(A[i1][i2][i3][i4])=L0+(i1⋅(d2d3d4)+i2⋅(d3d4)+i3⋅(d4)+i4)⋅wLOC(A[i_1][i_2][i_3][i_4]) = L_0 + \Big( i_1 \cdot (d_2 d_3 d_4) + i_2 \cdot (d_3 d_4) + i_3 \cdot (d_4) + i_4 \Big) \cdot w

---

### **Column-major (Fortran/MATLAB style, right → left)**

LOC(A[i1][i2][i3][i4])=L0+(i4⋅(d1d2d3)+i3⋅(d1d2)+i2⋅(d1)+i1)⋅wLOC(A[i_1][i_2][i_3][i_4]) = L_0 + \Big( i_4 \cdot (d_1 d_2 d_3) + i_3 \cdot (d_1 d_2) + i_2 \cdot (d_1) + i_1 \Big) \cdot w

---

## 🔹 General Formula for n Dimensions

Array: `A[d1][d2]...[dn]`  
Element: `A[i1][i2]...[in]`

---

### **Row-major (left → right)**

LOC(A[i1,i2,…,in])=L0+(∑p=1n(ip⋅∏q=p+1ndq))⋅wLOC(A[i_1,i_2,\dots,i_n]) = L_0 + \Bigg( \sum_{p=1}^{n} \Big( i_p \cdot \prod_{q=p+1}^{n} d_q \Big) \Bigg) \cdot w

👉 Each index `ip` is multiplied by the product of all dimensions _after it_.

---

### **Column-major (right → left)**

LOC(A[i1,i2,…,in])=L0+(∑p=1n(ip⋅∏q=1p−1dq))⋅wLOC(A[i_1,i_2,\dots,i_n]) = L_0 + \Bigg( \sum_{p=1}^{n} \Big( i_p \cdot \prod_{q=1}^{p-1} d_q \Big) \Bigg) \cdot w

👉 Each index `ip` is multiplied by the product of all dimensions _before it_.

---

## 🔹 Multiplication Complexity

- **Naïve expansion** → requires
    

n(n−1)2multiplications (O(n²))\frac{n(n-1)}{2} \quad \text{multiplications (O(n²))}

- **After applying Horner’s Rule** → only
    

n−1multiplications (O(n))n-1 \quad \text{multiplications (O(n))}

✅ Big win: modern compilers _always_ implement the optimized **Horner’s Rule form** internally.

---

## 🔹 Optimized Row-Major Formula (Horner’s Rule)

OFFSET=(((i1⋅d2+i2)⋅d3+i3)⋅d4+i4)⋅wOFFSET = (((i_1 \cdot d_2 + i_2) \cdot d_3 + i_3) \cdot d_4 + i_4) \cdot w

Generalized:

OFFSET=(((i1⋅d2+i2)⋅d3+i3)…dn+in)⋅wOFFSET = (((i_1 \cdot d_2 + i_2) \cdot d_3 + i_3) \dots d_n + i_n) \cdot w

---

✅ So the rule of thumb:

- **Row-major** = build expression **left to right** (outermost index has biggest weight).
    
- **Column-major** = build expression **right to left** (innermost index has biggest weight).
    

---

Would you like me to also **draw a worked-out 3D example (say 2×3×4)** in both row-major and column-major layouts so you can _see the memory mapping step-by-step_ the same way we did with 2D?