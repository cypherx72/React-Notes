Perfect â€” youâ€™ve nailed the **idea of nested recursion** with that tracing. Let me clean it up and highlight the key concepts so itâ€™s crystal clear in your head:

---

### ğŸ”¹ What is Nested Recursion?

- **Normal recursion:** A function calls itself with a _simpler parameter_ (e.g., `fun(n-1)`).
    
- **Nested recursion:** The parameter itself is a recursive call, like:
    
    ```c
    fun(n) {
        if (n > 100) return n - 10;
        else return fun(fun(n + 11));
    }
    ```
    
    â†’ Here, before `fun(n)` can proceed, it must compute **`fun(n+11)` first**.
    

So recursion is _nested inside itself_.

---

### ğŸ”¹ Key Phases in Nested Recursion

1. **Inner call evaluated first** â†’ you must resolve the inner recursion to get the parameter.
    
2. **Outer call executed next** â†’ the outer function uses that parameter and continues.
    

This is different from _simple recursion_ (where arguments are directly decreasing).

---

### ğŸ”¹ Example: `fun(95)`

```c
fun(95)
= fun(fun(106))     // since 95+11 = 106
```

Now:

```
fun(106) â†’ 106 > 100 â†’ returns 96
```

So:

```
fun(95) = fun(96)
```

Continue:

```
fun(96) = fun(fun(107))
fun(107) â†’ returns 97
so fun(96) = fun(97)

fun(97) = fun(fun(108))
fun(108) â†’ returns 98
so fun(97) = fun(98)

fun(98) = fun(fun(109))
fun(109) â†’ returns 99
so fun(98) = fun(99)

fun(99) = fun(fun(110))
fun(110) â†’ returns 100
so fun(99) = fun(100)

fun(100) = fun(fun(111))
fun(111) â†’ returns 101
so fun(100) = fun(101)

fun(101) â†’ returns 91
```

âœ… Final Answer: **fun(95) = 91**

---

### ğŸ”¹ Key Insights

- Nested recursion **expands rapidly** â†’ like a recursion tree but each step requires _evaluating another recursion_ first.
    
- Unlike linear recursion, you canâ€™t just decrement values step by step â€” you must resolve the **inner recursion first** before applying the outer one.
    
- This makes it **harder to trace manually** â€” which is why most nested recursions expand â€œlike anythingâ€ as you said.
    

---

ğŸ‘‰ Now hereâ€™s a question for you, Cypher:  
Do you want me to **generalize a formula/pattern** for this specific function (McCarthy 91 function) so that instead of tracing step by step, you can instantly tell the result for _any N_?