Perfect breakdown ðŸ‘Œ â€” youâ€™ve essentially nailed the intuition behind **static variables in recursion**.  
Let me sharpen and summarize the key distinctions between _ordinary local variables_ and _static variables_ when recursion is involved, so itâ€™s crystal clear:

---

### ðŸ”¹ Normal Local Variables in Recursion

- **Created fresh** each time the function is called (new activation record on the stack).
    
- **Destroyed** once the function returns.
    
- Each recursive call has its **own copy**.
    
- Example: in your first trace with `n`, every call had its own value (`5, 4, 3, 2, 1, 0`).
    

So the recursion tree had _different n values_ at each depth, and the return values accumulated accordingly â†’ final result `15`.

---

### ðŸ”¹ Static Variables in Recursion

- **Allocated only once** (in the _data segment_, not stack).
    
- **Lifetime = entire program run**, but scope is limited to the function.
    
- Every recursive call **shares the same copy**.
    
- Updates persist across recursive calls (not reset each time).
    

Thatâ€™s why when you introduced `static int x = 0;`,

- `x` was incremented across calls (`1 â†’ 2 â†’ 3 â†’ 4 â†’ 5`),
    
- but _every call_ on the way back saw the **same final value (5)**, not its own snapshot.
    

So instead of summing `1+2+3+4+5`, the recursion summed `5+5+5+5+5` â†’ `25`.

---

### ðŸ”¹ Key Rule for Tracing

When tracing recursion with a static variable:

- **Do not replicate it in each activation record** (like you do for locals).
    
- Keep a **single separate box** for the static variable, updating its value as recursion progresses.
    
- At return time, all recursive calls will access this single copy.
    

---

### ðŸ”¹ Comparison With Global Variable

- A global variable behaves the same way as a static inside recursion:  
    **single shared copy, persists across calls**.
    
- Difference:
    
    - `static` â†’ limited to that functionâ€™s scope.
        
    - `global` â†’ accessible everywhere.
        

So your observation that both produce the same result is correct.

---

âœ… So final recap with your function:

- With **local n** â†’ Result = `15`.
    
- With **static x** â†’ Result = `25`.
    
- With **global x** â†’ Same as static (`25`).
    

---

Would you like me to **draw a side-by-side stack + static/global memory diagram** for both cases (local vs static) so you can _visualize_ exactly how the values live in memory during recursion?