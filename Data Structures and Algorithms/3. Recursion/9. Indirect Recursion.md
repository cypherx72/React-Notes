Great — you’ve got the idea of **indirect recursion** nailed down 👌. Let me structure what you explained so it’s crisp and memorable:

---

### 🔹 What is Indirect Recursion?

- **Direct recursion** → function calls _itself_.
    
- **Indirect recursion** → a set of functions call each other in a cycle.  
    Example:
    
    - `A()` → calls `B()`
        
    - `B()` → calls `C()`
        
    - `C()` → calls `A()`  
        … and so on.
        

As long as the chain leads back to the original function, it’s recursion (just indirect).

---

### 🔹 Skeleton Example

```c
void A(int n) {
    if (n > 0) {
        printf("%d ", n);
        B(n - 1);   // call B with reduced n
    }
}

void B(int n) {
    if (n > 1) {
        printf("%d ", n);
        A(n / 2);   // call A with further reduced n
    }
}
```

---

### 🔹 Tracing the Call for `A(20)`

1. **A(20)** → prints `20`, calls `B(19)`
    
2. **B(19)** → prints `19`, calls `A(9)`
    
3. **A(9)** → prints `9`, calls `B(8)`
    
4. **B(8)** → prints `8`, calls `A(4)`
    
5. **A(4)** → prints `4`, calls `B(3)`
    
6. **B(3)** → prints `3`, calls `A(1)`
    
7. **A(1)** → prints `1`, calls `B(0)`
    
8. **B(0)** → condition fails → recursion stops
    

📌 Output sequence:

```
20 19 9 8 4 3 1
```

---

### 🔹 Key Insights

- **Termination is essential** → Without a proper base condition, indirect recursion can easily go infinite.
    
- **Two phases still exist (ascending & descending)** just like in direct recursion:
    
    - **Ascending** → as calls are made (`A → B → A → …`).
        
    - **Descending** → when conditions fail and calls start returning back.
        
- **Strength** → sometimes indirect recursion simplifies logic where breaking a task into two/more functions is natural.
    

---

👉 So you can think of indirect recursion as “**recursion spread across multiple functions**.”

Do you want me to also show you **how this looks on the call stack (step-by-step stack frames)** so you can visualize the ascending/descending more clearly?