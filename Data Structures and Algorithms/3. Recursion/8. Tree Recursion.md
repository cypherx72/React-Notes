Perfect ğŸ‘Œ Youâ€™ve walked through **Tree Recursion** with a detailed trace (calls, stack growth, output, time, and space). Let me now distill and structure it cleanly so you can use it as solid notes â€” a natural extension to what we did with Tail & Head recursion.

---

# ğŸŒ³ Tree Recursion

### **Definition**

- A recursive function is **Tree Recursive** if it calls itself **more than once** inside its body.
    
- Each call branches into multiple further calls â†’ forming a **recursion tree**.
    
- Contrast:
    
    - **Linear Recursion** â†’ only **one** recursive call per activation.
        
    - **Tree Recursion** â†’ **two or more** recursive calls per activation.
        

---

### âœ… Example

```c
void fun(int n) {
    if (n > 0) {
        printf("%d ", n);   // Processing
        fun(n - 1);         // 1st recursive call
        fun(n - 1);         // 2nd recursive call
    }
}
```

#### Execution for `fun(3)`

- First call: `fun(3)` â†’ prints **3**, then makes **two recursive calls with (2)**.
    
- Each `fun(2)` prints **2**, then makes two calls with (1).
    
- Each `fun(1)` prints **1**, then makes two calls with (0).
    
- `fun(0)` stops.
    

ğŸ‘‰ **Output order** depends on traversal of the recursion tree (like preorder).

---

### ğŸ”¹ Call Tree (for `fun(3)`)

```
fun(3)
 â”œâ”€ fun(2)
 â”‚   â”œâ”€ fun(1)
 â”‚   â”‚   â”œâ”€ fun(0)
 â”‚   â”‚   â””â”€ fun(0)
 â”‚   â””â”€ fun(1)
 â”‚       â”œâ”€ fun(0)
 â”‚       â””â”€ fun(0)
 â””â”€ fun(2)
     â”œâ”€ fun(1)
     â”‚   â”œâ”€ fun(0)
     â”‚   â””â”€ fun(0)
     â””â”€ fun(1)
         â”œâ”€ fun(0)
         â””â”€ fun(0)
```

---

### ğŸ”¹ Number of Calls

At each level:

- Level 0 â†’ `1` call (`fun(3)`)
    
- Level 1 â†’ `2` calls
    
- Level 2 â†’ `4` calls
    
- Level 3 â†’ `8` calls
    

ğŸ‘‰ Total calls = `1 + 2 + 4 + 8 = 15`

General formula:

1+2+22+23+...+2n=2n+1âˆ’11 + 2 + 2^2 + 2^3 + ... + 2^n = 2^{n+1} - 1

So, for input `n`, **total calls â‰ˆ 2^n**.

---

### ğŸ”¹ Time Complexity

- Each call does **constant work** (a `printf` + recursive calls).
    
- Total work = proportional to number of calls.
    
- **T(n) = O(2^n)**
    

---

### ğŸ”¹ Space Complexity

- Stack depth = **height of recursion tree**.
    
- Height = `n + 1` levels (from n â†’ 0).
    
- So, **Space = O(n)**.
    
- (Because old frames are reused once calls return â€” we donâ€™t store all `2^n` calls at once.)
    

---

### âš¡ Key Insights

1. **Linear Recursion** = 1 recursive call â†’ O(n) time, O(n) space.
    
2. **Tree Recursion** = 2+ recursive calls â†’ typically exponential time (e.g., O(2^n)).
    
3. **Space Complexity** stays linear O(n) because stack depth is bounded by recursion depth.
    
4. Very common in problems like **Fibonacci, subsets generation, binary tree traversals**.
    

---

âœ… So the â€œbig pictureâ€ so far:

- **Tail Recursion** â†’ work at call, easy loop conversion, O(n) time, O(1) space if optimized.
    
- **Head Recursion** â†’ work at return, harder loop conversion, O(n) time, O(n) space.
    
- **Tree Recursion** â†’ multiple calls per activation, time often O(2^n), space O(n).
    

---

Would you like me to now **show the Fibonacci example** (classic Tree Recursion case) with its recursion tree + time complexity analysis, or keep it at this general example for now?