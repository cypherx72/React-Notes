Perfect 👌 You’ve walked through **Tree Recursion** with a detailed trace (calls, stack growth, output, time, and space). Let me now distill and structure it cleanly so you can use it as solid notes — a natural extension to what we did with Tail & Head recursion.

---

# 🌳 Tree Recursion

### **Definition**

- A recursive function is **Tree Recursive** if it calls itself **more than once** inside its body.
    
- Each call branches into multiple further calls → forming a **recursion tree**.
    
- Contrast:
    
    - **Linear Recursion** → only **one** recursive call per activation.
        
    - **Tree Recursion** → **two or more** recursive calls per activation.
        

---

### ✅ Example

```c
void fun(int n) {
    if (n > 0) {
        printf("%d ", n);   // Processing
        fun(n - 1);         // 1st recursive call
        fun(n - 1);         // 2nd recursive call
    }
}
```

#### Execution for `fun(3)`

- First call: `fun(3)` → prints **3**, then makes **two recursive calls with (2)**.
    
- Each `fun(2)` prints **2**, then makes two calls with (1).
    
- Each `fun(1)` prints **1**, then makes two calls with (0).
    
- `fun(0)` stops.
    

👉 **Output order** depends on traversal of the recursion tree (like preorder).

---

### 🔹 Call Tree (for `fun(3)`)

```
fun(3)
 ├─ fun(2)
 │   ├─ fun(1)
 │   │   ├─ fun(0)
 │   │   └─ fun(0)
 │   └─ fun(1)
 │       ├─ fun(0)
 │       └─ fun(0)
 └─ fun(2)
     ├─ fun(1)
     │   ├─ fun(0)
     │   └─ fun(0)
     └─ fun(1)
         ├─ fun(0)
         └─ fun(0)
```

---

### 🔹 Number of Calls

At each level:

- Level 0 → `1` call (`fun(3)`)
    
- Level 1 → `2` calls
    
- Level 2 → `4` calls
    
- Level 3 → `8` calls
    

👉 Total calls = `1 + 2 + 4 + 8 = 15`

General formula:

1+2+22+23+...+2n=2n+1−11 + 2 + 2^2 + 2^3 + ... + 2^n = 2^{n+1} - 1

So, for input `n`, **total calls ≈ 2^n**.

---

### 🔹 Time Complexity

- Each call does **constant work** (a `printf` + recursive calls).
    
- Total work = proportional to number of calls.
    
- **T(n) = O(2^n)**
    

---

### 🔹 Space Complexity

- Stack depth = **height of recursion tree**.
    
- Height = `n + 1` levels (from n → 0).
    
- So, **Space = O(n)**.
    
- (Because old frames are reused once calls return — we don’t store all `2^n` calls at once.)
    

---

### ⚡ Key Insights

1. **Linear Recursion** = 1 recursive call → O(n) time, O(n) space.
    
2. **Tree Recursion** = 2+ recursive calls → typically exponential time (e.g., O(2^n)).
    
3. **Space Complexity** stays linear O(n) because stack depth is bounded by recursion depth.
    
4. Very common in problems like **Fibonacci, subsets generation, binary tree traversals**.
    

---

✅ So the “big picture” so far:

- **Tail Recursion** → work at call, easy loop conversion, O(n) time, O(1) space if optimized.
    
- **Head Recursion** → work at return, harder loop conversion, O(n) time, O(n) space.
    
- **Tree Recursion** → multiple calls per activation, time often O(2^n), space O(n).
    

---

Would you like me to now **show the Fibonacci example** (classic Tree Recursion case) with its recursion tree + time complexity analysis, or keep it at this general example for now?